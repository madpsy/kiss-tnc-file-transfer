<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>KISS File Transfer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="bootstrap.min.css" rel="stylesheet">
    <script src="socket.io.min.js"></script>
    <script src="crypto-js.min.js"></script>
    <script src="pako.min.js"></script>
    <script src="bootstrap.bundle.min.js"></script>
    <style>
        body { padding: 20px; }
        #status { margin-top: 1rem; font-weight: bold; }
        .progress { height: 20px; margin-bottom: 10px; }
        .inline-control { display: inline-block; vertical-align: middle; margin-left: 20px; }
        #connectionStatusDot {
          display: inline-block;
          width: 15px;
          height: 15px;
          border-radius: 50%;
          background-color: red;
          margin-left: 10px;
        }
.modal-dialog {
  display: table;
  width: auto;
  max-width: none;
}

#createTextFileModal .modal-dialog {
  display: block; /* or remove this line if not needed */
  max-width: 800px; /* Adjust width as needed */
  margin: 30px auto; /* Center the modal */
}
#fileViewModal .modal-dialog {
  display: block; /* or remove this line if not needed */
  max-width: 800px; /* Adjust width as needed */
  margin: 30px auto; /* Center the modal */
}
    </style>
</head>

<body>
    <div class="container">
        <h1>KISS File Transfer <span id="connectionStatusDot"></span></h1>
        <div class="dropdown" style="position: absolute; top: 20px; right: 20px; z-index: 1000;">
            <button class="btn btn-secondary dropdown-toggle" type="button" id="helpMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
	    Help
	  </button>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="helpMenuButton">
                <li><a class="dropdown-item" href="https://github.com/madpsy/kiss-tnc-file-transfer/" target="_blank">Github Repo</a></li>
                <li><a class="dropdown-item" href="help/readme-protocol.html" target="_blank">Protocol Spec</a></li>
                <li><a class="dropdown-item" href="help/readme-fileserver.html" target="_blank">File Server</a></li>
                <li><a class="dropdown-item" href="help/readme-fileserverclient.html" target="_blank">File Server Client</a></li>
                <li><a class="dropdown-item" href="help/readme-websockets.html" target="_blank">Websockets Server</a></li>
                <li><a class="dropdown-item" href="help/readme-sender.html" target="_blank">Sender</a></li>
                <li><a class="dropdown-item" href="help/readme-receiver.html" target="_blank">Receiver</a></li>
                <li><a class="dropdown-item" href="help/readme-repeater.html" target="_blank">Repeater</a></li>
                <li><a class="dropdown-item" href="help/readme-bridge.html" target="_blank">Bridge</a></li>
                <li><a class="dropdown-item" href="help/readme-passthrough.html" target="_blank">TNC Passthrough</a></li>
                <li><a class="dropdown-item" href="help/readme-monitor.html" target="_blank">Monitor Utility</a></li>
            </ul>
        </div>
        <div class="mb-3">
            <label for="connectionType" class="form-label">Connection Type</label> <select id="connectionType" class="form-select">
        <option value="serial" selected>
          Serial
        </option>
        <option value="websockets">
          Websockets
        </option>
      </select>
        </div>
        <div id="serialSettings" style="display: none;">
            <div class="mb-3">
                <label for="baudRate" class="form-label">Baud Rate</label> <select id="baudRate" class="form-select">
          <option value="9600">
            9600
          </option>
          <option value="14400">
            14400
          </option>
          <option value="19200">
            19200
          </option>
          <option value="38400">
            38400
          </option>
          <option value="57600">
            57600
          </option>
          <option value="115200" selected>
            115200
          </option>
        </select>
            </div><button id="serialConnectBtn" class="btn btn-primary">Connect</button> <button id="serialDisconnectBtn" class="btn btn-secondary" style="display: none;">Disconnect</button>
        </div><br>
        <div class="mb-3">
            <label for="senderCallsign" class="form-label">Your Callsign*</label> <input type="text" id="senderCallsign" class="form-control" placeholder="Enter your callsign">
        </div>
        <div class="mb-3">
            <label for="receiverCallsign" class="form-label">Remote Callsign</label> <input type="text" id="receiverCallsign" class="form-control" placeholder="Enter remote callsign">
        </div>
        <div class="mb-3">
            <div class="form-check">
                <input type="checkbox" class="form-check-input" id="restrictCallsign" checked>
                <label class="form-check-label" for="restrictCallsign">Only accept files from this callsign</label>
            </div>
            <div class="form-check">
                <input type="checkbox" class="form-check-input" id="isFileServer">
                <label class="form-check-label" for="isFileServer">Is a file server?</label>
            </div>
            <!-- Container where the List button will be added dynamically -->
            <span id="listButtonContainer"></span>
        </div>
        <div class="mb-3">
            <label for="fileInput" class="form-label">File to Send</label> <input type="file" id="fileInput" class="form-control">
        </div>

        <!-- Toggle button for Advanced Settings -->
        <button class="btn btn-link" type="button" data-bs-toggle="collapse" data-bs-target="#advancedSettings" aria-expanded="false" aria-controls="advancedSettings">
  Advanced Settings
</button>

        <!-- Collapsible Advanced Settings Section -->
        <div class="collapse" id="advancedSettings">

            <div class="card card-body">
                <div class="mb-3">
                    <label for="encodingMethod" class="form-label">Encoding Method</label> <select id="encodingMethod" class="form-select">
        <option value="binary" selected>
          Binary (fastest)
        </option>
        <option value="base64">
          Base64 (max compatibility)
        </option>
      </select>
                </div>
                <!-- Timeout Seconds -->
                <div class="mb-3">
                    <label for="timeoutSeconds" class="form-label">Timeout Seconds</label>
                    <input type="number" id="timeoutSeconds" class="form-control" value="5" step="1">
                </div>
                <!-- Timeout Retries -->
                <div class="mb-3">
                    <label for="timeoutRetries" class="form-label">Timeout Retries</label>
                    <input type="number" id="timeoutRetries" class="form-control" value="3" step="1">
                </div>
                <!-- Compress and Window Size -->
                <div class="mb-3">
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="compressCheckbox" checked>
                        <label class="form-check-label" for="compressCheckbox">Compress</label>
                    </div>
                    <div class="inline-control">
                        <label for="burstSlider" class="form-label" style="margin-bottom: 0;">
          Window Size: <span id="burstValue">4</span>
        </label>
                        <input type="range" class="form-range" id="burstSlider" min="0" max="5" step="1" value="2">
                    </div>
                    <div class="inline-control">
                        <div class="form-check" style="margin-left: 10px;">
                            <input type="checkbox" class="form-check-input" id="autoBurstCheckbox" checked> <label class="form-check-label" for="autoBurstCheckbox">Auto</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <div class="mb-3">
                <button id="sendFileBtn" class="btn btn-primary">Send File</button>
                <button id="createTextFileBtn" class="btn btn-primary">Create Text File</button>
                <div id="status"></div>
            </div>
            <div id="status"></div>
            <hr>
            <h2>Sender Progress</h2>
            <div id="senderProgress">
                <p>No file being sent.</p>
            </div>
            <hr>
            <h2>Sent Files</h2>
            <div id="sentFiles">
                <p>No files sent yet.</p>
            </div>
            <hr>
            <h2>Receiver Progress</h2>
            <div id="receiverProgress">
                <p>No active transfers.</p>
            </div>
            <hr>
            <h2>Received Files</h2>
            <div id="receivedFiles">
                <p>No files received yet.</p>
            </div>
            <div class="modal fade" id="listFiles" tabindex="-1" aria-labelledby="listFilesLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="listFilesLabel">File Server</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Rename these IDs for the list modal -->
                            <div id="cmdSentList"></div>
                            <div id="rspResponseList"></div>
                            <br>
                            <div id="listTable"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="cmdRspModal" tabindex="-1" aria-labelledby="cmdRspModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="cmdRspModalLabel">File Server</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Rename these IDs for the CMD/RSP modal -->
                            <div id="cmdSentCmdRsp"></div>
                            <div id="rspResponseCmdRsp"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal fade" id="fileViewModal" tabindex="-1" aria-labelledby="fileViewModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="fileViewModalLabel">View File</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <pre id="fileViewContent" class="form-control" style="white-space: pre-wrap; height: 300px; overflow: auto; resize: vertical;"></pre>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button id="editFileBtn" type="button" class="btn btn-primary">Edit</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="createTextFileModal" tabindex="-1" aria-labelledby="createTextFileModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="createTextFileModalLabel">Create Text File</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="textFileName" class="form-label">Filename</label>
                                <div class="input-group">
                                    <input type="text" id="textFileName" class="form-control" placeholder="Enter filename">
                                    <span class="input-group-text">.txt</span>
                                </div>
                            </div>
                            <div class="mb-3">
                                <label for="textFileContent" class="form-label">Content</label>
                                <textarea id="textFileContent" class="form-control" rows="10" placeholder="Type your text here..."></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button id="clearTextFileBtn" type="button" class="btn btn-warning">Clear</button>
                            <button id="modalSendFileBtn" type="button" class="btn btn-primary">Send File</button>
                        </div>
                    </div>
                </div>
            </div>

            <script>
                /***********************
                 * Global Variables
                 ***********************/
                let activeTransfers = {};
                let completedTransfers = {};
                let socket = null;
                let serialPort = null, serialWriter = null, serialReader = null, stopReading = false;
                let serialConnected = false;
                let kissBuffer = new Uint8Array(0);
                
                // Sender globals
                let maxRetries = 3;
                let burstSize = 4; // if auto mode is off; if auto then burstSize === 0
                let currentPacketIndex = 0;
                let currentRetries = 0, totalRetries = 0;
                let fileTransferInProgress = false, ackTimer = null, sentFileStats = null;
                const CHUNK_SIZE = 225;
                let headerAckReceived = false; // whether header ACK has been received
                let burstInProgress = false;
                let lastRangeAck = "";
                let duplicateAckCount = 0;
                let missingPackets = [];
                
                let fileDataChunks = [];
                let totalPackets = 0;
                
                // Sender/receiver identifiers
                let sender = "";
                let receiver = "";
                let fileId = "";
                let cachedListCSV = null;
                let expectedFileId = null;
                
                // Dynamic burst mode settings (allowed sizes: 1,2,4,6,8,10)
                const dynamicBurstSizes = [1, 2, 4, 6, 8, 10];
                let currentDynamicBurstIndex = 2; // default to 4 (index 2)
                let currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
                let consecutiveSuccessCount = 0;
                
                // Header retry and per-packet timing globals
                let headerSentTimestamp = 0;
                let headerAckTimer = null;
                let headerRetryCount = 0;
                const defaultPerPacketTimeout = 1500; // in milliseconds
                let perPacketTimeout = defaultPerPacketTimeout; // updated after header ACK arrives
                let defaultHeaderTimeout = 0; // computed based on timeoutSeconds
                
                // NEW: Variables to record burst timing for per-packet timeout update
                let burstStartTimestamp = 0;
                let lastBurstSentCount = 0; // actual number of packets sent in the burst
                
                // NEW: FIN-ACK retry loop variables – these are read from the UI.
                let finalAckRetryTimer = null;
                let currentFinAckRetryCount = 0;
                let waitingForFinAck = false;
                let maxFinalAckRetries = 0;  // from UI (#timeoutRetries)
                let finalAckTimeout = 0;     // from UI (#timeoutSeconds * 1000)
                let waitingForFinAckMap = {};
                let currentFileId = null;
                
                // Sender state display variables
                let senderState = "Sending";
                let senderStateTimestamp = 0;

		let currentViewedFile = null;
                
                // Track highest packet sequence number sent so far
                let highestPacketSentSoFar = 0;  
                
                /***********************
                 * Persistence Functions
                 ***********************/
            
              function waitForHeaderAck() {
              if (headerAckReceived) return; // Header ACK was received, so no need to wait further.
              headerRetryCount++;
              const timeoutRetries = parseInt(document.getElementById('timeoutRetries')?.value, 10) || 5;
              if (headerRetryCount > timeoutRetries) {
                updateStatus("No header ACK received after maximum retries. Aborting file transfer.");
                cancelSenderTransfer();
                return;
              }
              updateStatus("Timeout waiting for header ACK. Retrying header packet (retry " + headerRetryCount + " of " + timeoutRetries + ").");
              console.log("Resending header packet (seq 1) due to header ACK timeout, retry " + headerRetryCount);
              sendPacket(1);
              headerSentTimestamp = Date.now();
              // Increase the timeout for the next retry (exponential backoff)
              let newTimeout = defaultHeaderTimeout * Math.pow(1.5, headerRetryCount);
              headerAckTimer = setTimeout(waitForHeaderAck, newTimeout);
              }
            
            
                function saveReceivedFilesToLocalStorage(filesArray) {
                  try { localStorage.setItem("receivedFiles", JSON.stringify(filesArray)); }
                  catch (e) { console.error("Error saving received files:", e); }
                }
                function loadReceivedFilesFromLocalStorage() {
                  const data = localStorage.getItem("receivedFiles");
                  if (data) {
                    try { return JSON.parse(data); }
                    catch (e) { console.error("Error parsing received files:", e); }
                  }
                  return [];
                }
                function saveSentFilesToLocalStorage(filesArray) {
                  try { localStorage.setItem("sentFiles", JSON.stringify(filesArray)); }
                  catch (e) { console.error("Error saving sent files:", e); }
                }
                function loadSentFilesFromLocalStorage() {
                  const data = localStorage.getItem("sentFiles");
                  if (data) {
                    try { return JSON.parse(data); }
                    catch (e) { console.error("Error parsing sent files:", e); }
                  }
                  return [];
                }
                
                let persistentReceivedFiles = loadReceivedFilesFromLocalStorage();
                let persistentSentFiles = loadSentFilesFromLocalStorage();
                
                /***********************
                 * UI Update Functions
                 ***********************/
                function updateReceivedFilesUI() {
      const container = document.getElementById('receivedFiles');
      // Filter out any file with the name "LIST.txt"
      const filteredFiles = persistentReceivedFiles.filter(file => file.fileName.trim() !== "LIST.txt");
      if (!filteredFiles.length) {
        container.innerHTML = "<p>No files received yet.</p>";
        return;
      }
      let html = `<table class="table table-striped">
        <thead>
          <tr>
            <th>Date/Time</th>
            <th>Sender</th>
            <th>File Name</th>
            <th>ID</th>
            <th>Original</th>
            <th>Compressed</th>
            <th>Time (s)</th>
            <th>Speed (B/s)</th>
            <th>Duplicates</th>
            <th>MD5</th>
            <th></th>
            <th></th>
          </tr>
        </thead>
        <tbody>`;
filteredFiles.forEach((file) => {
  let checksumIcon = file.checksumMatch
    ? '<span style="color:green;">&#10004;</span>'
    : '<span style="color:red;">&#10008;</span>';
  let elapsedSec = file.elapsed / 1000;
  let speed = elapsedSec > 0 ? Math.floor((file.bytesReceived || file.size) / elapsedSec) : 0;
  let dupPercent = file.totalPackets ? Math.round((file.duplicates / file.totalPackets) * 100) : "0";
  
  // Only add a "View" button if the file extension is ".txt"
  // Choose a single action button: for .txt files use "View" and call viewReceivedFile; for others use "Download".
let actionButton;
if (file.fileName.toLowerCase().endsWith('.txt')) {
  actionButton = `<button class="btn btn-success btn-sm" onclick="viewReceivedFile('${file.fileId}')">View</button>`;
} else {
  actionButton = `<button class="btn btn-success btn-sm" onclick="downloadReceivedFile('${file.fileId}')">Download</button>`;
}

html += `<tr>
  <td>${new Date(file.timestamp).toLocaleString()}</td>
  <td>${file.sender}</td>
  <td>${file.fileName}</td>
  <td>${file.fileId}</td>
  <td>${file.originalSize} bytes</td>
  <td>${file.compressedSize} bytes</td>
  <td>${elapsedSec.toFixed(2)}</td>
  <td>${speed}</td>
  <td>${file.duplicates} (${dupPercent}%)</td>
  <td>${checksumIcon}</td>
  <td>${actionButton}</td>
  <td><button class="btn btn-danger btn-sm" onclick="deleteReceivedFileById('${file.fileId}')">Remove</button></td>
</tr>`;
});

      html += `</tbody></table>`;
      container.innerHTML = html;
    }
    
    function deleteReceivedFileById(fileId) {
      persistentReceivedFiles = persistentReceivedFiles.filter(file => file.fileId !== fileId);
      saveReceivedFilesToLocalStorage(persistentReceivedFiles);
      updateReceivedFilesUI();
    }  
                
                function updateSentFilesUI() {
                  const container = document.getElementById('sentFiles');
                  if (!persistentSentFiles.length) {
                    container.innerHTML = "<p>No files sent yet.</p>";
                    return;
                  }
                  let html = `<table class="table table-striped"><thead>
                    <tr><th>Date/Time</th><th>Receiver</th><th>File Name</th>
                    <th>Original Size</th><th>Compressed Size</th>
                    <th>Retries</th><th>Total Time (s)</th><th>Speed (Bytes/s)</th><th>Clear</th></tr>
                    </thead><tbody>`;
                  persistentSentFiles.forEach((stat, index) => {
                    let totalTime = parseFloat(stat.totalTime);
                    let speed = totalTime > 0 ? Math.floor(stat.bytesSent / totalTime) : 0;
                    html += `<tr>
                      <td>${new Date(stat.timestamp).toLocaleString()}</td>
                      <td>${stat.receiver || ""}</td>
                      <td>${stat.fileName}</td>
                      <td>${stat.originalSize} bytes</td>
                      <td>${stat.compressedSize} bytes</td>
                      <td>${stat.totalRetries}</td>
                      <td>${stat.totalTime}</td>
                      <td>${speed}</td>
                      <td><button class="btn btn-warning btn-sm" onclick="clearSentFile(${index})">Clear</button></td>
                    </tr>`;
                  });
                  html += "</tbody></table>";
                  container.innerHTML = html;
                }
                
             function updateReceiverProgressUI() {
              const container = document.getElementById('receiverProgress');
              if (Object.keys(activeTransfers).length === 0) {
                container.innerHTML = "<p>No active transfers.</p>";
                return;
              }
              let html = "";
              for (let key in activeTransfers) {
                let transfer = activeTransfers[key];
            
                // total number of packets expected for the transfer (ensure it's at least 1 to avoid divide-by-zero)
                let total = transfer.totalChunks || 1;
            
                // 'cumulative' is the last contiguous packet number received (i.e. all packets 1...lastAcked are received)
                let cumulative = transfer.lastAcked || 1;
            
                // Now calculate the burst window progress:
                let burstBlue = 0;   // number of packets in the current burst that have been received
                let burstOrange = 0; // number of packets still expected in the current burst
            
                if (transfer.currentBurstTo && transfer.currentBurstTo > cumulative) {
                  let burstWindowSize = transfer.currentBurstTo - cumulative;
                  // Count how many packets in the burst window have arrived:
                  for (let seq = cumulative + 1; seq <= transfer.currentBurstTo; seq++) {
                    if (transfer.received[seq]) {
                      burstBlue++;
                    }
                  }
                  burstOrange = burstWindowSize - burstBlue;
                }
            
                // The overall blue portion is the cumulative packets plus any burst packets that have arrived:
                let blueTotal = cumulative + burstBlue;
            
                // Calculate the percentages relative to the total number of packets:
                let bluePercent = Math.floor((blueTotal / total) * 100);
                let orangePercent = Math.floor((burstOrange / total) * 100);
            
                // Build the single progress bar with two segments:
                let progressBarHTML = `
                  <div class="progress mb-2" style="height: 20px;">
                    <!-- Blue: contiguous plus burst packets already received -->
                    <div class="progress-bar bg-primary" role="progressbar"
                         style="width: ${bluePercent}%;" aria-valuenow="${bluePercent}"
                         aria-valuemin="0" aria-valuemax="100">
                      ${bluePercent > 0 ? bluePercent + '%' : ''}
                    </div>
                    <!-- Orange: expected burst packets not yet received -->
                    <div class="progress-bar bg-warning" role="progressbar"
                         style="width: ${orangePercent}%;" aria-valuenow="${orangePercent}"
                         aria-valuemin="0" aria-valuemax="100">
                      ${orangePercent > 0 ? orangePercent + '%' : ''}
                    </div>
                  </div>
                `;
            
                html += `
                  <div class="mb-2 border p-2">
                    <h5>From ${key.split("_")[0]} – ${transfer.header ? transfer.header.fileName : "Unknown file"} (ID: ${transfer.header ? transfer.header.fileId : "N/A"})</h5>
                    <p>${blueTotal} of ${total} packets received</p>
                    ${progressBarHTML}
                    <p>
                      Status: ${(transfer.lastAckTime && (Date.now() - transfer.lastAckTime < 1100))
                               ? '<span style="color: blue; font-weight: bold;">Ack</span>'
                               : '<span style="color: green; font-weight: bold;">Receiving</span>'}
                    </p>
                    <div style="margin-top: 0.5rem;">
                      <button class="btn btn-danger btn-sm" onclick="cancelReceiverTransfer('${key}')">Cancel</button>
                    </div>
                  </div>
                `;
              }
              container.innerHTML = html;
            }
            
                
              function updateSenderProgressUI() {
              const container = document.getElementById('senderProgress');
              if (!fileTransferInProgress || totalPackets === 0) {
                container.innerHTML = "<p>No file being sent.</p>";
                return;
              }
              const now = Date.now();
              const elapsed = (now - sentFileStats.startTime) / 1000;
            
              // Calculate the percentage of packets acked and sent
              const ackedPercent = Math.floor((currentPacketIndex / totalPackets) * 100);
              const sentPercent = Math.floor((highestPacketSentSoFar / totalPackets) * 100);
              const orangePercent = sentPercent - ackedPercent; // sent but not yet acked
            
              let eta = "N/A";
              if (ackedPercent > 0) {
                let estimatedTotal = elapsed / (ackedPercent / 100);
                eta = (estimatedTotal - elapsed).toFixed(2) + " s";
              }
              const transferRate = elapsed > 0 ? sentFileStats.bytesSent / elapsed : 0;
              const retriesSoFar = totalRetries + currentRetries;
              const retryPercent = totalPackets ? Math.round((retriesSoFar / totalPackets) * 100) : 0;
            
              let statusText = "";
              if (ackTimer || (senderState === "Awaiting ACK" && (now - senderStateTimestamp < 1000))) {
                statusText = '<span style="color: orange; font-weight: bold;">Awaiting ACK</span>';
              } else {
                senderState = "Sending";
                statusText = '<span style="color: red; font-weight: bold;">Sending</span>';
              }
            
              container.innerHTML = `
                <h5>To ${sentFileStats.receiver} – ${sentFileStats.fileName} (ID: ${sentFileStats.fileId})<br>
                  (Acked: ${currentPacketIndex} / ${totalPackets}, Sent: ${highestPacketSentSoFar} / ${totalPackets})
                </h5>
                <p>Original Size: ${sentFileStats.originalSize} bytes; Compressed Size: ${sentFileStats.compressedSize} bytes</p>
                <div class="progress mb-2" style="height: 20px;">
                  <!-- Blue progress for acked packets -->
                  <div class="progress-bar bg-primary" role="progressbar" 
                       style="width: ${ackedPercent}%;" aria-valuenow="${ackedPercent}" 
                       aria-valuemin="0" aria-valuemax="100">
                       ${ackedPercent}%
                  </div>
                  <!-- Orange progress for packets sent but not yet acked -->
                  <div class="progress-bar bg-warning" role="progressbar" 
                       style="width: ${orangePercent}%;" aria-valuenow="${orangePercent}" 
                       aria-valuemin="0" aria-valuemax="100">
                       ${orangePercent > 0 ? orangePercent + '%' : ''}
                  </div>
                </div>
                <p>
                  ${statusText}<br>
                  Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} 
                  (${transferRate.toFixed(0)} bytes/sec); Retries: ${retriesSoFar} (${retryPercent}%)
                </p>
                <div style="margin-top: 0.5rem;">
                  <button class="btn btn-danger btn-sm" onclick="cancelSenderTransfer()">Cancel</button>
                </div>
              `;
              }
            
            
            function finalizeTransfer() {
              updateStatus("File transfer complete.");
              sentFileStats.endTime = Date.now();
              sentFileStats.totalTime = ((sentFileStats.endTime - sentFileStats.startTime) / 1000).toFixed(2);
              sentFileStats.totalRetries = totalRetries + currentRetries;
              sentFileStats.timestamp = sentFileStats.startTime;
              persistentSentFiles.push(sentFileStats);
              saveSentFilesToLocalStorage(persistentSentFiles);
              updateSentFilesUI();
            
              // Capture final file ID for the final handshake:
              finalFileId = sentFileStats.fileId; // new global variable on sender side
            
              fileTransferInProgress = false;
              updateSenderProgressUI();
              for (let key in activeTransfers) {
                if (activeTransfers[key].completed) {
                  delete activeTransfers[key];
                }
              }
              updateReceiverProgressUI();
              document.getElementById('sendFileBtn').disabled = false;
            
              // Start the FIN-ACK wait loop with the captured finalFileId.
              startFinAckWaitLoop(finalFileId);
              
              // Note: Do NOT clear sentFileStats immediately; let the FIN-ACK loop complete.
            }
            
            
            
            
              function startTransfer(fileId) {
              waitingForFinAckMap[fileId] = true; // Set final ACK wait for this specific fileId
              console.log("Transfer started with fileId:", currentFileId);
              }
            
                /***********************
                 * Receiver ACK Function
                 ***********************/
            function sendAckFromReceiver(sender, fileId, ackStr) {
              let localCallsign = document.getElementById('senderCallsign').value.trim();
              // Build info field using only fileId, "ACK", and ackStr.
              const info = fileId + ':' + "ACK" + ':' + ackStr;
              const encoder = new TextEncoder();
              const infoBytes = encoder.encode(info);
              const ax25Header = buildAX25Header(localCallsign, sender);
              const ackPacket = new Uint8Array(ax25Header.length + infoBytes.length);
              ackPacket.set(ax25Header, 0);
              ackPacket.set(infoBytes, ax25Header.length);
              const ackKissFrame = buildKissFrame(ackPacket);
              console.log("Receiver sending ACK:", ackStr);
              
              // Update transfer record if needed, then send via the appropriate connection.
              if (document.getElementById('connectionType').value === 'websockets') {
                if (socket) socket.emit('raw_kiss_frame', ackKissFrame);
              } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
                serialWriter.write(ackKissFrame).catch(err => console.error("Error writing ACK:", err));
              }
            }
            
                
                /***********************
                 * Helper Functions: Range Compression/Expansion
                 ***********************/
                function compressRanges(arr) {
                  if (!arr.length) return "";
                  arr = arr.map(Number).sort((a, b) => a - b);
                  let ranges = [];
                  let start = arr[0], prev = arr[0];
                  for (let i = 1; i < arr.length; i++) {
                    if (arr[i] === prev + 1) {
                      prev = arr[i];
                    } else {
                      ranges.push(start === prev ? String(start) : start + "-" + prev);
                      start = arr[i];
                      prev = arr[i];
                    }
                  }
                  ranges.push(start === prev ? String(start) : start + "-" + prev);
                  return ranges.join(",");
                }
                
                function expandRanges(rangeStr) {
                  let result = [];
                  let parts = rangeStr.split(",");
                  parts.forEach(part => {
                    let trimmed = part.trim();
                    if (!trimmed) return;
                    if (trimmed.indexOf("-") !== -1) {
                      let [start, end] = trimmed.split("-").map(x => parseInt(x, 16));
                      if (!isNaN(start) && !isNaN(end)) {
                        if (start > end) { [start, end] = [end, start]; }
                        for (let i = start; i <= end; i++) result.push(i);
                      } else if (!isNaN(start)) {
                        result.push(start);
                      }
                    } else {
                      let num = parseInt(trimmed, 16);
                      if (!isNaN(num)) result.push(num);
                    }
                  });
                  return result;
                }
                
                // NEW: Minimal implementation of updateBurstSlider to update the burst slider and label.
                function updateBurstSlider(index) {
                  const slider = document.getElementById('burstSlider');
                  const label = document.getElementById('burstValue');
                  if (slider) {
                    slider.value = index;
                  }
                  if (label) {
                    label.textContent = dynamicBurstSizes[index];
                  }
                }
                
                /***********************
                 * Utility Functions
                 ***********************/
                function padCallsign(cs) {
                  return cs.toUpperCase().padEnd(9, ' ');
                }
                
    
                
                /***********************
                 * AX.25 Header Helpers
                 ***********************/
                function encodeAX25Address(callsign, isLast) {
                  let call = callsign.toUpperCase();
                  let ssid = 0;
                  if (call.includes('-')) {
                    const parts = call.split('-');
                    call = parts[0];
                    ssid = parseInt(parts[1], 10) || 0;
                  }
                  call = call.padEnd(6, ' ').slice(0, 6);
                  const addr = new Uint8Array(7);
                  for (let i = 0; i < 6; i++) {
                    addr[i] = call.charCodeAt(i) << 1;
                  }
                  addr[6] = ((ssid & 0x0F) << 1) | 0x60;
                  if (isLast) addr[6] |= 0x01;
                  return addr;
                }
                
            function decodeAX25Address(addr) {
              // Expects a Uint8Array of length 7.
              let cs = "";
              for (let i = 0; i < 6; i++) {
                cs += String.fromCharCode(addr[i] >> 1);
              }
              cs = cs.trim();
              let ssid = (addr[6] >> 1) & 0x0F;
              if (ssid > 0) {
                cs += "-" + ssid;
              }
              return cs;
            }
            
            
                function buildAX25Header(source, destination) {
                  const destAddr = encodeAX25Address(destination, false);
                  const srcAddr = encodeAX25Address(source, true);
                  const control = new Uint8Array([0x03]);
                  const pid = new Uint8Array([0xF0]);
                  const header = new Uint8Array(7 + 7 + 1 + 1);
                  header.set(destAddr, 0);
                  header.set(srcAddr, 7);
                  header.set(control, 14);
                  header.set(pid, 15);
                  return header;
                }
                
                /***********************
                 * Packet Building Functions
                 ***********************/
            function buildPacket(sender, receiver, seq, totalPackets, payloadChunk, fileId, burstTo) {
              let seqStr = seq.toString(16).padStart(4, '0');
              let burstToStr = burstTo.toString(16).padStart(4, '0');
              let infoStr = "";
              if (seq === 1) {
                let totalStr = (totalPackets - 1).toString(16).padStart(4, '0');
                // Header packets now include only the fileId and sequence fields.
                infoStr = fileId + ':' + "0001" + burstToStr + '/' + totalStr + ':';
              } else {
                infoStr = fileId + ':' + seqStr + burstToStr + ':';
              }
              const encoder = new TextEncoder();
              const infoBytes = encoder.encode(infoStr);
              const innerPayload = new Uint8Array(infoBytes.length + payloadChunk.length);
              innerPayload.set(infoBytes, 0);
              innerPayload.set(payloadChunk, infoBytes.length);
              const ax25Header = buildAX25Header(sender, receiver);
              const packetBytes = new Uint8Array(ax25Header.length + innerPayload.length);
              packetBytes.set(ax25Header, 0);
              packetBytes.set(innerPayload, ax25Header.length);
              return packetBytes;
            }
            
                
                /***********************
                 * Receiver ACK Functions
                 ***********************/
            function sendCumulativeAck(transfer, sender, forceSend = false) {
              if (transfer.finalHandshakeReceived) {
                console.log("Final handshake received; skipping cumulative ACK.");
                return;
              }
              // Determine the highest contiguous packet number starting from packet 1.
              let cumulative = 1;
              while (transfer.received[cumulative]) {
                cumulative++;
              }
              cumulative--;  // highest contiguous packet number
            
              // Build the cumulative ACK string.
              let ackStr = cumulative > 1 
                ? "0001-" + cumulative.toString(16).padStart(4, '0') 
                : "0001";
            
              console.log("Receiver: Cumulative ACK for file", transfer.header.fileId, ":", ackStr);
              // Always use the fileId stored in the transfer header.
              sendAckFromReceiver(sender, transfer.header.fileId, ackStr);
              transfer.lastAcked = cumulative;
            }
            
                
                /***********************
                 * ACK Processing Functions
                 ***********************/
            function processAckFrame(infoText) {
              if (infoText.indexOf(":ACK:") === -1) return null;
              let parts = infoText.split(":");
              // Expect at least three fields: [fileId, "ACK", ackValue, ...]
              if (parts.length < 3) return null;
              return { fileId: parts[0].trim(), ack: parts[2].trim() };
            }
            
            
                
            
              function processAck(ackContent) {
              // Ensure the current ack is for the correct fileId
              if (waitingForFinAckMap[sentFileStats.fileId] && ackContent !== "0001" && waitingForFinAck) {
                console.log(`Sender: Received cumulative ACK during final wait for file ${sentFileStats.fileId} (waitingForFinAck is ${waitingForFinAck}), re-sending final FIN-ACK.`);
                sendFinalFinAck(sentFileStats.fileId);  // Resend the FIN-ACK for the correct fileId
                return;
              }
            
              // Process header ACK handling
              if (ackContent === "0001") {
                if (!headerAckReceived) {
                  headerAckReceived = true;
                  let headerAckTime = Date.now() - headerSentTimestamp;
                  perPacketTimeout = headerAckTime / 2;
                  console.log(`Processed header ACK: 0001; header ack time: ${headerAckTime}ms, setting perPacketTimeout to ${perPacketTimeout}ms`);
                  currentPacketIndex = 1;
                  if (headerAckTimer) {
                    clearTimeout(headerAckTimer);
                    headerAckTimer = null;
                  }
                  if (!burstInProgress) {
                    sendBurstPackets();
                  }
                } else {
                  console.log("Duplicate header ACK received; resending next set of packets.");
                  sendBurstPackets();
                }
                return;
              }
            
              // Handle range ACKs (ackContent with '-' or ',')
              if (ackContent.indexOf('-') !== -1 || ackContent.indexOf(',') !== -1) {
                processRangeAck(ackContent);
                return;
              }
            
              // Handle duplicate ACKs
              if (ackContent === lastRangeAck) {
                duplicateAckCount++;
                console.log(`Received duplicate ACK (${duplicateAckCount}):`, ackContent);
                sendBurstPackets();
                if (duplicateAckCount >= 3) {
                  console.log("Three duplicate ACKs received; resending missing packets:", missingPackets);
                  missingPackets.forEach(seq => { 
                    sendPacket(seq); 
                    totalRetries++; 
                  });
                  duplicateAckCount = 0;
                }
                return;
              } else {
                duplicateAckCount = 0;
                lastRangeAck = ackContent;
              }
            
              // Update currentPacketIndex based on the received ack number.
              let ackNum = parseInt(ackContent, 16);
              if (!isNaN(ackNum) && ackNum > currentPacketIndex) {
                currentPacketIndex = ackNum;
                console.log("Sender: Cumulative ACK updated currentPacketIndex to", currentPacketIndex);
                updateSenderProgressUI();
              }
            
              // Handle final packet receipt (check for completion)
              if (currentPacketIndex >= totalPackets &&
                  highestPacketSentSoFar >= totalPackets &&
                  missingPackets.length === 0) {
                updateStatus("Final ACK received. Sending FIN-ACK immediately.");
                sendFinalFinAck(currentFileId);
                finalizeTransfer();
                return;
              }
            
              // Send next burst if not in final wait and burst is not in progress.
              if (!burstInProgress && currentPacketIndex < totalPackets) {
                sendBurstPackets();
              }
              }
            
            
                
            
              function processRangeAck(ackContent) {
              // Expand the ACK range to get all acknowledged packet numbers.
              let receivedList = expandRanges(ackContent).sort((a, b) => a - b);
            
              // Determine the highest contiguous packet number acknowledged.
              let newIndex = currentPacketIndex;
              let expected = currentPacketIndex + 1;
              while (receivedList.includes(expected)) {
                newIndex = expected;
                expected++;
              }
            
              // If the new index is not greater than currentPacketIndex, it’s a duplicate.
              if (newIndex <= currentPacketIndex) {
                duplicateAckCount++;
                console.log("Received duplicate range ACK (" + duplicateAckCount + "):", ackContent);
                sendBurstPackets();
                return;
              }
            
              // Update state.
              duplicateAckCount = 0;
              lastRangeAck = ackContent;
              currentPacketIndex = newIndex;
            
              console.log("Sender: Cumulative ACK received. Updating highest contiguous ACK to", newIndex);
            
              if (ackTimer) {
                clearTimeout(ackTimer);
                ackTimer = null;
              }
              burstInProgress = false;
              updateSenderProgressUI();
            
              // Check for final packet receipt regardless of burst mode.
              if (currentPacketIndex >= totalPackets &&
                highestPacketSentSoFar >= totalPackets &&
                missingPackets.length === 0) {
                updateStatus("Final ACK received.");
                finalizeTransfer();
                return;
              }
            
              // For non-auto mode, continue sending burst packets if needed.
              if (burstSize !== 0 && currentPacketIndex < totalPackets) {
                sendBurstPackets();
              }
            
              // For auto mode, handle dynamic burst (automatic sliding window) logic.
              if (burstSize === 0) { 
                if (missingPackets.length === 0) {
                  consecutiveSuccessCount++;
                  console.log("Consecutive success count:", consecutiveSuccessCount);
                  if (consecutiveSuccessCount >= 2) {
                    if (currentDynamicBurstIndex < dynamicBurstSizes.length - 1) {
                      currentDynamicBurstIndex++;
                      currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
                      console.log("Dynamic burst increased to", currentBurstSizeDynamic);
                      updateBurstSlider(currentDynamicBurstIndex);
                    } else {
                      console.log("Dynamic burst is already at maximum index.");
                    }
                    consecutiveSuccessCount = 0;
                  }
                } else {
                  if (currentDynamicBurstIndex > 0) {
                    currentDynamicBurstIndex--;
                    currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
                    console.log("Dynamic burst decreased to", currentBurstSizeDynamic);
                    updateBurstSlider(currentDynamicBurstIndex);
                  }
                  consecutiveSuccessCount = 0;
                }
                sendBurstPackets();
              }
              }
            
                
                /***********************
                 * FIN-ACK Functions (Sender & Receiver) – UPDATED WITH RETRY LOOP
                 ***********************/
            function sendFinalFinAck(fileId) {
      if (waitingForFinAckMap[fileId]) {
        // Construct the info payload like a normal ACK.
        const finalInfo = fileId + ':' + "ACK" + ':' + "FIN-ACK";
        const encoder = new TextEncoder();
        const infoBytes = encoder.encode(finalInfo);
        const ax25Header = buildAX25Header(sender, receiver);
        const packetBytes = new Uint8Array(ax25Header.length + infoBytes.length);
        packetBytes.set(ax25Header, 0);
        packetBytes.set(infoBytes, ax25Header.length);
        const finalFrame = buildKissFrame(packetBytes);
        console.log(`Sender: Sending FIN-ACK for file ${fileId}.`);
        if (document.getElementById('connectionType').value === 'websockets') {
          if (socket) socket.emit('raw_kiss_frame', finalFrame);
        } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
          serialWriter.write(finalFrame).catch(err => console.error("Error sending FIN-ACK:", err));
        }
      } else {
        console.log(`Sender: No such fileId waiting for FIN-ACK ${fileId}.`);
      }
    }
    
            
            
                
            function startFinAckWaitLoop(fileId) {
              // Get base timeout from UI and compute finalAckTimeout
              let baseTimeout = parseFloat(document.getElementById('timeoutSeconds').value) * 1000;
              finalAckTimeout = baseTimeout ? baseTimeout * 1.5 : 7500;
            
              waitingForFinAck = true;
              console.log("Sender: Sending FIN-ACK and starting final wait period of " + finalAckTimeout + " ms. File ID:", fileId);
              sendFinalFinAck(fileId);
            
              finalAckRetryTimer = setTimeout(() => {
                console.log("Sender: Final wait period expired; ending FIN-ACK wait loop.");
                waitingForFinAck = false;
                // Now that the FIN-ACK loop is done, you can clear sentFileStats if desired:
                sentFileStats = null;
              }, finalAckTimeout);
            }
            
            
            function scheduleNextFinAckAttempt(fileId) {
              if (!waitingForFinAck) return;
              if (currentFinAckRetryCount >= maxFinalAckRetries) {
                console.log("Sender: Gave up waiting for final FIN-ACK after", currentFinAckRetryCount, "retries.");
                waitingForFinAck = false;
                return;
              }
              currentFinAckRetryCount++;
              console.log(`Sender: Attempt #${currentFinAckRetryCount}, waiting for FIN-ACK for ${finalAckTimeout} ms... File ID: ${fileId}`);
              finalAckRetryTimer = setTimeout(() => {
                if (!waitingForFinAck) return;
                console.log("Sender: FIN-ACK timeout reached, resending FIN-ACK...");
                sendFinalFinAck(fileId);
                scheduleNextFinAckAttempt(fileId);
              }, finalAckTimeout);
            }
            
                
                /***********************
                 * Process Raw Packet (Updated FIN-ACK handling)
                 ***********************/
            function processRawPacket(packet) {
              console.log("Processing raw packet:", packet);
              let packetBytes;
              if (typeof packet === 'string') {
                packetBytes = new TextEncoder().encode(packet);
              } else if (packet instanceof ArrayBuffer) {
                packetBytes = new Uint8Array(packet);
              } else if (packet instanceof Uint8Array) {
                packetBytes = packet;
              } else {
                console.log("Unrecognized packet type; ignoring.");
                return;
              }
            
              if (packetBytes[0] !== 0xC0 || packetBytes[packetBytes.length - 1] !== 0xC0) {
                console.error("Invalid KISS frame: missing framing bytes.");
                return;
              }
            
            const ax25Frame = packetBytes.slice(2, packetBytes.length - 1);
            if (ax25Frame.length < 16) {
              return;
            }
            const header = ax25Frame.slice(0, 16); // Extract the first 16 bytes as the AX.25 header
            const infoField = ax25Frame.slice(16);
            let infoText = new TextDecoder().decode(infoField);
        
            // --- New: Process RSP packets (responses to CMD packets) ---
if (infoText.split(":")[1] && infoText.split(":")[1].toUpperCase() === "RSP") {
  const rsp = parseRspPacket(infoField);
  if (rsp.ok && pendingCmdResponses[rsp.cmdID]) {
    pendingCmdResponses[rsp.cmdID].resolve(rsp);
    delete pendingCmdResponses[rsp.cmdID];
  } else {
    console.warn("Received RSP for unknown CMD ID or with error:", rsp.error);
  }
  return;
}

            
            if (infoText.indexOf(":ACK:FIN-ACK") !== -1) {
              let parts = infoText.split(":"); // Expected format: fileId, "ACK", "FIN-ACK"
              if (parts.length < 3) return;
              let fileIdFromAck = parts[0].trim();
              let localCallsign = document.getElementById('senderCallsign').value.trim();
              // Now look up the active transfer using fileIdFromAck
              for (let key in activeTransfers) {
                let transfer = activeTransfers[key];
                if (transfer.header && transfer.header.fileId === fileIdFromAck) {
                  if (!transfer.waitingForFinAck) {
                    console.log("Receiver: Received FIN-ACK but not waiting for it. Ignoring.");
                    return;
                  }
                  console.log("Receiver: FIN-ACK received for file", fileIdFromAck, "for transfer", key);
                  transfer.finalHandshakeReceived = true;
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                  return;
                }
              }
              console.log("Receiver: FIN-ACK received, but no active transfer matches fileId", fileIdFromAck);
              return;
            }
            
            
            
              // *** NEW: Check for ACK frames before processing as data/header packet ***
            if (infoText.indexOf(":ACK:") !== -1) {
              let ackData = processAckFrame(infoText);
              if (!ackData) return;
              
              // Check against active transfer state if available...
              if (sentFileStats) {
                if (ackData.fileId !== sentFileStats.fileId) {
                  console.log("Ignoring ACK for file", ackData.fileId, "while current file is", sentFileStats.fileId);
                  return;
                }
              } 
              // If no active transfer, check finalFileId:
              else if (finalFileId) {
                if (ackData.fileId !== finalFileId) {
                  console.log("Ignoring ACK for file", ackData.fileId, "while final file is", finalFileId);
                  return;
                }
              } 
              // If neither, ignore.
              else {
                console.log("No active transfer or final file; ignoring ACK.");
                return;
              }
              
              console.log("Sender received ACK:", ackData.ack, "for file", ackData.fileId);
              processAck(ackData.ack);
              if (ackTimer) { clearTimeout(ackTimer); ackTimer = null; }
              burstInProgress = false;
              return;
            }
            
              // *** End of ACK check ***
            
            
            // Now decode sender/receiver from the header:
            const senderStr = decodeAX25Address(header.slice(7, 14));
            const receiverStr = decodeAX25Address(header.slice(0, 7));
    
    	if (document.getElementById('restrictCallsign').checked) {
    	  const allowedCallsign = document.getElementById('receiverCallsign').value.trim().toUpperCase();
    	  if (senderStr !== allowedCallsign) {
    	    console.log(`Ignoring packet from ${senderStr} as it does not match remote callsign ${allowedCallsign}.`);
    	    return;
    	  }
    	}
           
            // Then parse the info field which now has the new format:
            // Expected formats:
            //   - ACK packets: fileId + ':' + "ACK" + ':' + ackValue + ':'
            //   - Data packets (header, seq==1): fileId + ':' + "0001XXXX/YYYY" + ':'
            //   - Data packets (seq > 1): fileId + ':' + seq(4 hex digits) + burstTo(4 hex digits) + ':'
            let parts = infoText.split(":");
            if (parts.length < 2) {
              console.log("Packet format invalid: not enough fields");
              return;
            }
            let packetFileId = parts[0].trim();
            let seqBurst = parts[1].trim();
            
            let seq, burstTo;
            if (seqBurst.indexOf("/") !== -1) {
              // Header packet (seq==1); expect format like "0001XXXX/YYYY"
              seq = 1;
              if (seqBurst.length < 8) {
                console.log("Header packet format invalid: insufficient length");
                return;
              }
              burstTo = parseInt(seqBurst.substring(4, 8), 16);
            } else {
              // Data packet; expect exactly 8 hex digits
              if (seqBurst.length !== 8) {
                console.log("Data packet format invalid: sequence field length is not 8");
                return;
              }
              seq = parseInt(seqBurst.substring(0, 4), 16);
              burstTo = parseInt(seqBurst.substring(4, 8), 16);
            }
            
            
              // Ignore packets not addressed to me
              if (receiverStr !== document.getElementById('senderCallsign').value.trim()) {
                console.log("Ignoring packet not intended for me (packet receiver:",
                  receiverStr, ", local:", document.getElementById('senderCallsign').value.trim(), ")");
                return;
              }
            
              // Calculate payload offset based on sequence number
              let offset = (seq === 1) ? 17 : 12;
              let payloadChunk = unescapeKissData(infoField.slice(offset));
            
              let transferKeyFinal = senderStr + "_" + packetFileId;
            
              // --- Header Branch: When seq === 1, start a new transfer ---
             
            // --- Header Branch: When seq === 1, start a new transfer ---
            if (seq === 1 && !activeTransfers[transferKeyFinal]) {
    
      let headerFileId = packetFileId; // obtained from the packet header
      
      // If file server mode is enabled and we have an expected fileId from GET,
      // ensure that they match.
      if (document.getElementById('isFileServer').checked && expectedFileId) {
        if (headerFileId !== expectedFileId) {
          console.error("Incoming file ID does not match expected cmdID:", headerFileId, expectedFileId);
          // Optionally, ignore this transfer:
          return;
        }
      }
    
    
              console.log("Starting new transfer from sender", senderStr, "with file ID", packetFileId);
              // Decode the header payload to get the transfer parameters
              let headerPayloadText = new TextDecoder().decode(payloadChunk);
              let parts = headerPayloadText.split("|");
              // Calculate header timeout based on the first part (timeoutSeconds)
              const headerTimeout = (parseFloat(parts[0]) * 1000) + 1500;
              
              activeTransfers[transferKeyFinal] = {
                totalChunks: parseInt(parts[9], 10),
                received: {},
                startTime: Date.now(),
                duplicateCount: 0,
                lastUpdate: Date.now(),
                ackTimer: null,
                lastPacketTime: Date.now(),
                ackDelay: headerTimeout, // calculated from header data
                currentBurstBoundary: 0,
                burstStartTime: Date.now(),
                maxAckRetries: parseInt(parts[1], 10) || 5,
                ackRetryCount: 0,
                ackRetryActive: true
              };
            
              activeTransfers[transferKeyFinal].received[1] = true;
            
              activeTransfers[transferKeyFinal].header = {
                fileName: parts[2],
                originalSize: parseInt(parts[3], 10),
                compressedSize: parseInt(parts[4], 10),
                md5: parts[5],
                fileId: packetFileId, // store the file ID from the packet
                encodingMethod: parseInt(parts[7], 10),
                compression: (parts[8] === "1"),
                expectedTotal: parseInt(parts[9], 10)
              };
            
              console.log("Received header from sender", senderStr, "for file ID", packetFileId, activeTransfers[transferKeyFinal].header);
              sendAckFromReceiver(senderStr, packetFileId, "0001");
              return;
            }
            
            
              let transfer = activeTransfers[transferKeyFinal];
              if (!transfer) {
              console.log("No active transfer record for", transferKeyFinal, "- transfer already finalized.");
              return;
              }
            
              if (!transfer.currentBurstTo || burstTo > transfer.currentBurstTo) {
                transfer.currentBurstTo = burstTo;
              }
            
              let isDuplicate = !!transfer.received[seq];
              if (!isDuplicate) {
                transfer.received[seq] = payloadChunk;
              } else {
                transfer.duplicateCount++;
                console.log("Duplicate packet", seq, "received from", transferKeyFinal);
              }
            
              if (!transfer.rawBytesReceived) transfer.rawBytesReceived = 0;
              transfer.rawBytesReceived += infoField.length;
              transfer.lastUpdate = Date.now();
              console.log("Stored packet", seq, "from", transferKeyFinal, `(${Object.keys(transfer.received).length} / ${transfer.totalChunks})`);
              updateReceiverProgressUI();
            
              if (seq === 1) return;
            
              let contiguous = 2;
              while (transfer.received[contiguous]) contiguous++;
              transfer.lastAcked = contiguous - 1;
            
              // --- ACK sending branch: Send ACK and start exponential retry ---
              if (!isDuplicate && !transfer.completed) {
                transfer.lastPacketTime = Date.now();
                if (transfer.ackTimer) {
                  clearTimeout(transfer.ackTimer);
                  transfer.ackTimer = null;
                }
                // Reset the ACK retry counter for this ACK cycle
                transfer.ackRetryCount = 0;
                
                if ((contiguous - 1) >= burstTo) {
                  console.log("Receiver: Reached highest burst seq (" + burstTo + "), ACKing immediately.");
                  sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
            
              (function ackRetry() {
              // Immediately exit if the final handshake is complete.
              if (transfer.finalHandshakeReceived) {
                console.log("Receiver: Final handshake done, stopping ACK retries.");
                return;
              }
              if (transfer.ackRetryCount >= transfer.maxAckRetries) {
                console.log("Receiver: ACK retry max reached (" + transfer.maxAckRetries + "). Aborting transfer.");
                // Mark the transfer as aborted or remove it from activeTransfers.
                delete activeTransfers[senderStr + "_" + transfer.header.fileId];
                updateReceiverProgressUI();
                updateStatus("Receiver: Transfer for file " + transfer.header.fileId + " aborted due to ACK timeout.");
                transfer.ackTimer = null;
                return;
              }
              transfer.ackRetryCount++;
              let nextDelay = transfer.ackDelay * Math.pow(1.5, transfer.ackRetryCount);
              transfer.ackTimer = setTimeout(() => {
                if (transfer.finalHandshakeReceived) {
                  console.log("Receiver: Final handshake received; not resending cumulative ACK.");
                  return;
                }
                console.log("Receiver: ACK retry attempt #" + transfer.ackRetryCount + ", resending cumulative ACK.");
                sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
                ackRetry();
              }, nextDelay);
              })();
            
            
                } else {
                  transfer.ackTimer = setTimeout(() => {
                    console.log("Receiver: Idle period reached, sending partial/cumulative ACK.");
                    sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
                    transfer.ackTimer = null;
                  }, transfer.ackDelay);
                }
              }
            
              let allPacketsReceived = transfer.totalChunks && Object.keys(transfer.received).length === transfer.totalChunks;
            
            if (!transfer.completed && allPacketsReceived) {
              if (transfer.downloadTriggered) return;
              transfer.downloadTriggered = true;
            
              if (transfer.header && persistentReceivedFiles.some(f => f.fileId === transfer.header.fileId && f.sender === senderStr)) {
                console.log("File already processed, skipping reassembly and download.");
                return;
              }
            
                console.log("All packets received for", transferKeyFinal, "- reassembling file...");
                if (!transfer.header) {
                  console.error("Missing header for", transferKeyFinal);
                  return;
                }
            
                let dataChunks = [];
                for (let i = 2; i <= transfer.totalChunks; i++) {
                  if (!transfer.received[i]) {
                    console.error("Missing packet", i, "for", transferKeyFinal);
                    return;
                  }
                  let chunk = transfer.received[i];
                  if (transfer.header.encodingMethod === 1) {
                    let base64Str = new TextDecoder().decode(chunk);
                    let binaryStr = atob(base64Str);
                    let decodedChunk = new Uint8Array(binaryStr.length);
                    for (let j = 0; j < binaryStr.length; j++) {
                      decodedChunk[j] = binaryStr.charCodeAt(j);
                    }
                    dataChunks.push(decodedChunk);
                  } else {
                    dataChunks.push(chunk);
                  }
                }
                let totalLength = dataChunks.reduce((acc, c) => acc + c.length, 0);
                let fullCompressed = new Uint8Array(totalLength);
                let offsetVal = 0;
                dataChunks.forEach(chunk => {
                  fullCompressed.set(chunk, offsetVal);
                  offsetVal += chunk.length;
                });
                console.log("Reassembled compressed file length:", fullCompressed.length);
            
                let decompressed;
                if (transfer.header.compression) {
                  try {
                    decompressed = pako.inflate(fullCompressed);
                  } catch (err) {
                    console.error("Error decompressing file for", transferKeyFinal, ":", err);
                    return;
                  }
                } else {
                  decompressed = fullCompressed;
                }
                if (!decompressed) {
                  console.error("Decompression failed: decompressed data is undefined");
                  return;
                }
                console.log("Decompressed file length:", decompressed.length);
            
                const blob = new Blob([decompressed]);
        
        if (transfer.header.fileName.trim() === "LIST.txt") {
          // Process the CSV asynchronously.
          const readerText = new FileReader();
          readerText.onload = function(e) {
            const csvText = e.target.result;
            processListFile(csvText);
            // Optionally, update state to indicate that LIST.txt has been handled.
          };
          readerText.onerror = function(e) {
            console.error("Error reading LIST file:", e);
          };
          readerText.readAsText(blob);
        
          // Instead of returning immediately, allow the FIN-ACK process to complete.
          // You might set a flag so that the normal download isn't triggered later.
          transfer.isListFile = true;
          console.log("Processing LIST.txt file via CSV parser, but continuing with FIN-ACK.");
          // Do not return here—continue so that the final ack cycle still runs.
        }
        
                const elapsedTotal = Date.now() - transfer.startTime;
                const dupCount = transfer.duplicateCount;
                const computedMd5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(decompressed)).toString();
                const checksumMatch = (computedMd5 === transfer.header.md5);
            
                const fileObj = {
                  sender: senderStr,
                  fileName: transfer.header.fileName,
                  originalSize: transfer.header.originalSize,
                  compressedSize: transfer.header.compressedSize,
                  size: blob.size,
                  elapsed: elapsedTotal,
                  duplicates: dupCount,
                  totalPackets: transfer.totalChunks,
                  timestamp: Date.now(),
                  checksumMatch: checksumMatch,
                  bytesReceived: transfer.rawBytesReceived || 0,
                  fileId: transfer.header.fileId
                };
            
                const reader = new FileReader();
                reader.onload = function(e) {
                  fileObj.dataUrl = e.target.result;
                  let existingIndex = persistentReceivedFiles.findIndex(
                    f => f.fileId === fileObj.fileId && f.sender === fileObj.sender
                  );
                  if (existingIndex !== -1) {
                    persistentReceivedFiles[existingIndex] = fileObj;
                  } else {
                    persistentReceivedFiles.push(fileObj);
                    existingIndex = persistentReceivedFiles.length - 1;
                  }
                  saveReceivedFilesToLocalStorage(persistentReceivedFiles);
                  updateReceivedFilesUI();
            
                  if (checksumMatch) {
        	    if (!transfer.isListFile) {
                    	downloadReceivedFile(fileObj.fileId);
			if (fileObj.fileName.toLowerCase().endsWith('.txt')) {
				viewReceivedFile(fileObj.fileId);
			}
        	    } else {
        		console.log("LIST.txt processed; skipping normal download.");
                    }
                  } else {
                    console.error("Checksum does not match; automatic download aborted.");
                    updateStatus("Received file failed checksum verification.");
                  }
                };
                reader.onerror = function(e) {
                  console.error("Error converting Blob:", e);
                };
                reader.readAsDataURL(blob);
                console.log("Receiver: Entire file complete.");
            
            console.log("Receiver: Entire file complete. Sending final cumulative ACK and waiting for FIN-ACK.");
              transfer.waitingForFinAck = true;  // Mark that we are waiting for the sender's FIN-ACK. 
              // Do not mark transfer.completed or remove it yet.
              return;
              }
              }
            
                
                /***********************
                 * Sender ACK Handling & Burst Sending
                 ***********************/
                function sendBurstPackets() {
                  if (!fileTransferInProgress) return;
                  if (missingPackets.length > 0) {
                    console.log("Sender: Resending missing packets:", missingPackets);
                    missingPackets.forEach(seq => { 
                      sendPacket(seq); 
                      totalRetries++; 
                    });
                    let effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
                    const fixedTimeout = defaultPerPacketTimeout;
                    let effectiveTimeout = (burstSize === 0) ? perPacketTimeout : fixedTimeout;
                    const ackTimeout = effectiveBurst * effectiveTimeout + 500;
                    senderState = "Awaiting ACK";
                    senderStateTimestamp = Date.now();
                    ackTimer = setTimeout(() => {
                      console.log("Sender: No ACK received for missing packets; resending missing packets again.");
                      missingPackets.forEach(seq => { sendPacket(seq); });
                      burstInProgress = false;
                    }, ackTimeout);
                    return;
                  }
                  if (currentPacketIndex >= totalPackets) {
                    updateStatus("File transfer complete.");
                    sentFileStats.endTime = Date.now();
                    sentFileStats.totalTime = ((sentFileStats.endTime - sentFileStats.startTime) / 1000).toFixed(2);
                    sentFileStats.totalRetries = totalRetries + currentRetries;
                    sentFileStats.timestamp = sentFileStats.startTime;
                    persistentSentFiles.push(sentFileStats);
                    saveSentFilesToLocalStorage(persistentSentFiles);
                    updateSentFilesUI();
                    sentFileStats = null;
                    totalRetries = 0;
                    fileTransferInProgress = false;
                    updateSenderProgressUI();
                    for (let key in activeTransfers) {
                      if (activeTransfers[key].completed) {
                        delete activeTransfers[key];
                      }
                    }
                    updateReceiverProgressUI();
                    document.getElementById('sendFileBtn').disabled = false;
                    // Instead of a single waitForFinalAck call, start the retry loop.
                    startFinAckWaitLoop();
                    return;
                  }
                  if (burstInProgress) return;
                  burstInProgress = true;
                  let effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
                  let startSeq = currentPacketIndex + 1;
                  let endSeq = Math.min(totalPackets, currentPacketIndex + effectiveBurst);
                  // NEW: Record burst start time and the actual number of packets sent.
                  burstStartTimestamp = Date.now();
                  lastBurstSentCount = endSeq - startSeq + 1;
                  updateSenderProgressUI();
                  for (let seq = startSeq; seq <= endSeq; seq++) {
                    sendPacket(seq);
                  }
                  const ackTimeout = effectiveBurst * perPacketTimeout + 500;
                  senderState = "Awaiting ACK";
                  senderStateTimestamp = Date.now();
                  ackTimer = setTimeout(() => {
                    console.log("Sender: No ACK received; re-sending missing packets again.");
                    totalRetries += missingPackets.length;
                    missingPackets.forEach(seq => { sendPacket(seq); });
                    burstInProgress = false;
                  }, ackTimeout);
                }
                
                function sendPacket(seq) {
                  if (seq > highestPacketSentSoFar) {
                    highestPacketSentSoFar = seq; 
                  }
                  let payloadChunk = fileDataChunks[seq - 1];
                  let effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
                  let currentBurstTo = Math.min(totalPackets, currentPacketIndex + effectiveBurst);
                  if (seq === 1) {
                    currentBurstTo = 1;
                  }
                  let packet = buildPacket(sender, receiver, seq, totalPackets, payloadChunk, fileId, currentBurstTo);
                  sentFileStats.bytesSent = (sentFileStats.bytesSent || 0) + packet.length;
                  console.log(`Sending packet ${seq} of ${totalPackets}`);
                  const kissFrame = buildKissFrame(packet);
            
                  if (document.getElementById('connectionType').value === 'websockets') {
                    if (socket) socket.emit('raw_kiss_frame', kissFrame);
                  } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
                    serialWriter.write(kissFrame).catch(err => console.error("Error sending packet:", err));
                  }
                }
                
                /***********************
                 * KISS Framing Functions
                 ***********************/
                function escapeKissData(data) {
                  let output = [];
                  for (let i = 0; i < data.length; i++) {
                    let byte = data[i];
                    if (byte === 0xC0) output.push(0xDB, 0xDC);
                    else if (byte === 0xDB) output.push(0xDB, 0xDD);
                    else output.push(byte);
                  }
                  return new Uint8Array(output);
                }
                
                function unescapeKissData(data) {
                  let output = [];
                  for (let i = 0; i < data.length; i++) {
                    if (data[i] === 0xDB && i + 1 < data.length) {
                      if (data[i+1] === 0xDC) { output.push(0xC0); i++; continue; }
                      else if (data[i+1] === 0xDD) { output.push(0xDB); i++; continue; }
                    }
                    output.push(data[i]);
                  }
                  return new Uint8Array(output);
                }
                
                function buildKissFrame(aprsPacket) {
                  const escapedPacket = escapeKissData(aprsPacket);
                  const KISS_FLAG = 0xC0, KISS_CMD_DATA = 0x00;
                  let frame = new Uint8Array(1 + 1 + escapedPacket.length + 1);
                  frame[0] = KISS_FLAG;
                  frame[1] = KISS_CMD_DATA;
                  frame.set(escapedPacket, 2);
                  frame[frame.length - 1] = KISS_FLAG;
                  return frame;
                }
                
                function concatUint8Arrays(a, b) {
                  let c = new Uint8Array(a.length + b.length);
                  c.set(a, 0);
                  c.set(b, a.length);
                  return c;
                }
                
                window.processRawPacket = processRawPacket;
                
                function updateConnectionIndicator() {
                  const dot = document.getElementById('connectionStatusDot');
                  if (document.getElementById('connectionType').value === 'websockets')
                    dot.style.backgroundColor = (socket && socket.connected) ? 'green' : 'red';
                  else
                    dot.style.backgroundColor = serialConnected ? 'green' : 'red';
                  updateSendButtonStatus();
    	      updateListFilesButtonStatus();
                }
                
                function updateSendButtonStatus() {
                  const sendBtn = document.getElementById('sendFileBtn');
                  sendBtn.disabled = (document.getElementById('connectionType').value === 'websockets')
                                     ? !(socket && socket.connected) : !serialConnected;
                }
                
              function initializeWebSocket() {
              if (socket) return;
              socket = io('/');
              // Removed logging from onAny:
              socket.onAny((event, ...args) => { /* No logging here */ });
            
              socket.on('connect', () => { 
                console.log("Websocket connected, id:", socket.id);
                updateConnectionIndicator();
              });
            
              socket.on('disconnect', () => { 
                console.log("Websocket disconnected.");
                updateConnectionIndicator();
              });
            
              socket.on('connect_error', (err) => { 
                // Removed logging for connect_error
                updateConnectionIndicator();
              });
            
              socket.on('raw_kiss_frame', (packet) => { 
                // Removed logging for raw_kiss_frame
                processRawPacket(packet);
              });
            
              updateConnectionIndicator();
              }
            
                
                async function readSerial() {
      // Continue reading as long as the serial port is open and has a readable stream.
      while (serialPort && serialPort.readable && !stopReading) {
        // Use the global serialReader variable.
        serialReader = serialPort.readable.getReader();
        try {
          while (true) {
            // Check the flag inside the inner loop, too.
            if (stopReading) break;
    
            const { value, done } = await serialReader.read();
            if (done) break;
            if (value) {
              // Append new data to the buffer.
              kissBuffer = concatUint8Arrays(kissBuffer, value);
              // Process complete frames from the buffer.
              let startIndex = kissBuffer.indexOf(0xC0);
              while (startIndex !== -1) {
                let endIndex = kissBuffer.indexOf(0xC0, startIndex + 1);
                if (endIndex === -1) break;
                const frame = kissBuffer.slice(startIndex, endIndex + 1);
                processRawPacket(frame);
                kissBuffer = kissBuffer.slice(endIndex + 1);
                startIndex = kissBuffer.indexOf(0xC0);
              }
            }
          }
        } catch (error) {
          console.error("Error reading serial port:", error);
        } finally {
      if (serialReader && typeof serialReader.releaseLock === 'function') {
        serialReader.releaseLock();
        serialReader = null;
      }
    }
      }
    }
                
                document.addEventListener("DOMContentLoaded", function() {

		  const params = new URLSearchParams(window.location.search);
		  const connectionParam = params.get('connection');

		  if (connectionParam === 'serial' || connectionParam === 'websockets') {
		    const connectionSelect = document.getElementById('connectionType');
		    connectionSelect.value = connectionParam;
		  }

                  const storedSenderCallsign = localStorage.getItem('senderCallsign');
                  if (storedSenderCallsign) {
                    document.getElementById('senderCallsign').value = storedSenderCallsign;
                  }
                
                  const storedReceiverCallsign = localStorage.getItem('receiverCallsign');
                  if (storedReceiverCallsign) {
                    document.getElementById('receiverCallsign').value = storedReceiverCallsign;
                  }
                
                  // 3) Set up event listeners to persist changes back to localStorage
                  document.getElementById('senderCallsign').addEventListener('input', () => {
                    localStorage.setItem('senderCallsign', document.getElementById('senderCallsign').value);
                  });
                
                  document.getElementById('receiverCallsign').addEventListener('input', () => {
                    localStorage.setItem('receiverCallsign', document.getElementById('receiverCallsign').value);
                  });
        
                const fileServerCheckbox = document.getElementById('isFileServer');
                const listButtonContainer = document.getElementById('listButtonContainer');
	if (document.getElementById('connectionType').value === 'serial') {
	   document.getElementById('serialSettings').style.display = 'block';
	}        

        if (fileServerCheckbox.checked) {
          const listBtn = document.createElement('button');
          listBtn.id = "listFilesBtn";
          listBtn.className = "btn btn-info btn-sm ms-2";
          listBtn.innerText = "List Files";
          listBtn.addEventListener('click', openListFilesModal);
          listButtonContainer.appendChild(listBtn);
        }
        updateListFilesButtonStatus();
        
        document.getElementById('senderCallsign').addEventListener('input', updateListFilesButtonStatus);
    document.getElementById('receiverCallsign').addEventListener('input', updateListFilesButtonStatus);
    
        
                fileServerCheckbox.addEventListener('change', function() {
                  // Clear the container first.
                  listButtonContainer.innerHTML = "";
                  if (this.checked) {
                    const listBtn = document.createElement('button');
                    listBtn.id = "listFilesBtn";
                    listBtn.className = "btn btn-info btn-sm ms-2";
                    listBtn.innerText = "List Files";
                    listBtn.addEventListener('click', openListFilesModal);
                    listButtonContainer.appendChild(listBtn);
    		updateListFilesButtonStatus();
                  }
                });
        
                  const autoCheckbox = document.getElementById('autoBurstCheckbox');
                  const burstSlider = document.getElementById('burstSlider');
                  burstSlider.disabled = autoCheckbox.checked;
                  autoCheckbox.addEventListener('change', function() {
                    burstSlider.disabled = this.checked;
                  });
                
                  updateReceivedFilesUI();
                  updateSentFilesUI();
                  if (document.getElementById('connectionType').value === 'websockets') {
                    initializeWebSocket();
                  }
                  document.getElementById('connectionType').addEventListener('change', async function(e) {
                    const connectionType = e.target.value;
                    if (connectionType === 'serial') {
                      document.getElementById('serialSettings').style.display = 'block';
                      if (socket) {
                        socket.disconnect();
                        socket = null;
                        console.log("Websocket closed (serial selected).");
                      }
                      updateConnectionIndicator();
                    } else {
                      document.getElementById('serialSettings').style.display = 'none';
                      if (serialPort) {
                        try { await serialPort.close(); console.log("Serial port closed."); }
                        catch (err) { console.error("Error closing serial port:", err); }
                        serialPort = null;
                        serialWriter = null;
                        serialConnected = false;
                      }
                      if (!socket) initializeWebSocket();
                      updateConnectionIndicator();
                    }
                  });
                  document.getElementById('serialConnectBtn').addEventListener('click', async () => {
                    if ("serial" in navigator) {
                      try {
                        serialPort = await navigator.serial.requestPort();
                        const baudRate = parseInt(document.getElementById('baudRate').value, 10);
                        await serialPort.open({ baudRate: baudRate });
                        serialConnected = true;
                        serialWriter = serialPort.writable.getWriter();
                        readSerial();
                        updateStatus("Serial port connected at " + baudRate);
                        updateConnectionIndicator();
                        document.getElementById('serialConnectBtn').style.display = 'none';
                        document.getElementById('serialDisconnectBtn').style.display = 'inline-block';
                      } catch (error) {
                        console.error("Error opening serial port:", error);
                        alert("Failed to open serial port: " + error);
                        serialConnected = false;
                        updateConnectionIndicator();
                      }
                    } else {
                      alert("Web Serial API not supported in this browser. Try using Google Chrome");
                      serialConnected = false;
                      updateConnectionIndicator();
                    }
                  });
    	document.getElementById('serialDisconnectBtn').addEventListener('click', async () => {
      if (serialPort) {
        try {
          // Signal the read loop to stop.
          stopReading = true;
    if (serialReader) {
      await serialReader.cancel().catch(err => console.warn("Cancel error:", err));
      if (serialReader && typeof serialReader.releaseLock === 'function') {
        serialReader.releaseLock();
      }
      serialReader = null;
    }
    
          if (serialWriter) {
            serialWriter.releaseLock();
            serialWriter = null;
          }
          await serialPort.close();
          console.log("Serial port closed.");
          serialPort = null;
          serialConnected = false;
          updateConnectionIndicator();
          document.getElementById('serialConnectBtn').style.display = 'inline-block';
          document.getElementById('serialDisconnectBtn').style.display = 'none';
          // Reset the flag for future connections.
          stopReading = false;
        } catch (err) {
          console.error("Error closing serial port:", err);
        }
      }
    });
    
        document.getElementById('sendFileBtn').addEventListener('click', () => {
          // Reset burst counters.
          currentDynamicBurstIndex = 2;
          currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
          consecutiveSuccessCount = 0;
          
          if (fileTransferInProgress) {
            alert("A file transfer is already in progress.");
            return;
          }
          
          document.getElementById('sendFileBtn').disabled = true;
          
          // Validate inputs.
          const inputs = validateFileTransferInputs();
          if (!inputs) {
            document.getElementById('sendFileBtn').disabled = false;
            return;
          }
          sender = inputs.sender;
          receiver = inputs.receiver;
          const file = inputs.file;
          
          // Get additional options.
          const compress = document.getElementById('compressCheckbox').checked;
          const encodingMethod = document.getElementById('encodingMethod').value;
          
          // Set up burst settings.
          configureBurstSettings();
          
          // Branch based on whether "Is file server?" is checked.
          if (document.getElementById('isFileServer').checked) {
            // Open the dedicated CMD/RSP modal.
            const cmdModal = openCmdRspModal();
            document.getElementById('cmdSentCmdRsp').innerText = "CMD: PUT " + file.name;
            document.getElementById('rspResponseCmdRsp').innerText = "";
        
            
            // Send the PUT command and wait for a response.
            sendCmdWithRetry("PUT " + file.name)
              .then(rsp => {
                document.getElementById('rspResponseCmdRsp').innerText =
                  "RSP: " + (rsp.status === 1 ? "Success" : "Failure") + " - " + rsp.message;
                if (rsp.status === 1) {
      // Use the command's cmdID as the file ID.
      fileId = rsp.cmdID;
      // After 1 second, close the modal, scroll to the bottom, and proceed.
      setTimeout(() => {
  closeCmdRspModal();
  document.getElementById('senderProgress').scrollIntoView({ behavior: 'smooth' });
  startTransfer(fileId);
  prepareFileTransferData(file, compress, encodingMethod, fileId)
    .then(data => {
      initiateFileTransfer(data, file, sender, receiver, fileId);
    })
    .catch(err => {
      updateStatus("Error reading file: " + err);
      document.getElementById('sendFileBtn').disabled = false;
    });
}, 1000);
                } else {
                  document.getElementById('sendFileBtn').disabled = false;
                }
              })
              .catch(err => {
                document.getElementById('rspResponseCmdRsp').innerText = "Error: " + err;
                document.getElementById('sendFileBtn').disabled = false;
              });
          } else {
            // Normal file transfer: generate a file ID, start transfer, and prepare the file data.
            fileId = generateTwoCharID();
            startTransfer(fileId);
            prepareFileTransferData(file, compress, encodingMethod, fileId)
              .then(data => {
                initiateFileTransfer(data, file, sender, receiver, fileId);
              })
              .catch(err => {
                updateStatus("Error reading file: " + err);
                document.getElementById('sendFileBtn').disabled = false;
              });
          }
        });
        
        
        
        
        
                  document.getElementById('burstSlider').addEventListener('input', function() {
                    let burstValue = dynamicBurstSizes[parseInt(this.value, 10)];
                    document.getElementById('burstValue').textContent = burstValue;
                  });
                  document.getElementById('autoBurstCheckbox').addEventListener('change', function() {
                    document.getElementById('burstSlider').disabled = this.checked;
                  });
                
                  setInterval(() => {
                    updateSenderProgressUI();
                    updateReceiverProgressUI();
                  }, 1000);
                });
                
                function updateStatus(msg) {
                  document.getElementById('status').innerText = msg;
                  console.log(msg);
                }
    		window.downloadReceivedFile = function(fileId) {
    		  const file = persistentReceivedFiles.find(f => f.fileId === fileId);
    		  if (!file) return;
    		  const a = document.createElement('a');
    		  a.href = file.dataUrl;
    		  a.download = file.fileName;
    		  document.body.appendChild(a);
    		  a.click();
    		  document.body.removeChild(a);
    		};
    
                window.clearSentFile = function(index) {
                  persistentSentFiles.splice(index, 1);
                  saveSentFilesToLocalStorage(persistentSentFiles);
                  updateSentFilesUI();
                };
                window.deleteReceivedFile = function(index) {
                  persistentReceivedFiles.splice(index, 1);
                  saveReceivedFilesToLocalStorage(persistentReceivedFiles);
                  updateReceivedFilesUI();
                };
                window.reAckTransfer = function(key) {
                  let transfer = activeTransfers[key];
                  if (!transfer) return;
                  const senderStr = key.split("_")[0];
                  const fileId = key.split("_")[1];
                  console.log("[Re-ACK] Manually resending cumulative ACK for:", key);
                  sendCumulativeAck(transfer, senderStr, fileId, true);
                };
                function cancelReceiverTransfer(key) {
                  let transfer = activeTransfers[key];
                  if (!transfer) return;
                  
                  if (transfer.ackTimer) {
                    clearTimeout(transfer.ackTimer);
                    transfer.ackTimer = null;
                  }
                  
                  updateStatus("Receiver transfer " + key + " canceled.");
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                }
                
                function manualResend() {
                  console.log("Manual Re-Send triggered by sender. Resending missing packets...");
                  sendBurstPackets();
                }
                
                function cancelSenderTransfer() {
                  if (fileTransferInProgress) {
                    fileTransferInProgress = false;
                    if (ackTimer) clearTimeout(ackTimer);
                    if (headerAckTimer) clearTimeout(headerAckTimer);
                    updateStatus("File transfer canceled.");
                    updateSenderProgressUI();
                    document.getElementById('sendFileBtn').disabled = false;
                  }
                }
              document.getElementById('senderCallsign').addEventListener('input', function() {
              this.value = this.value.toUpperCase();
              });
            
              document.getElementById('receiverCallsign').addEventListener('input', function() {
              this.value = this.value.toUpperCase();
              });
              // Periodically check for transfers that haven't received new packets and force an ACK resend.
              setInterval(() => {
              const now = Date.now();
              for (const key in activeTransfers) {
                const transfer = activeTransfers[key];
                // Skip transfers that are already finalized.
                if (transfer.finalHandshakeReceived || transfer.completed) continue;
                
                // Log the current retry count and max retries.
                console.log(`Periodic check for transfer ${key}: current retry ${transfer.ackRetryCount} of ${transfer.maxAckRetries}`);
                
                // Check if maximum ACK retries have been reached.
                if (transfer.ackRetryCount >= transfer.maxAckRetries) {
                  console.log(`Receiver: Maximum ACK retries reached for transfer ${key} (retry ${transfer.ackRetryCount} of ${transfer.maxAckRetries}). Aborting transfer.`);
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                  updateStatus("Receiver: Transfer for file " + transfer.header.fileId + " aborted due to ACK timeout.");
                  continue;
                }
                
                // If enough time has passed since the last packet, force a resend.
                if (now - transfer.lastPacketTime > transfer.ackDelay) {
                  // Increment the retry counter here.
                  transfer.ackRetryCount++;
                  console.log(`Periodic check: ACK retry attempt ${transfer.ackRetryCount} for transfer ${key} (max ${transfer.maxAckRetries}). Resending ACK.`);
                  sendCumulativeAck(transfer, key.split("_")[0], transfer.header.fileId, true);
                  // Update the last packet time to prevent too-frequent retries.
                  transfer.lastPacketTime = now;
                }
              }
              }, 1000);
        
        
    
    
        
        // Build a CMD packet given your callsigns and command text.
function buildCmdPacket(myCallsign, fileServerCallsign, commandText) {
  const header = buildAX25Header(myCallsign, fileServerCallsign);
  const cmdID = generateTwoCharID();
  // New format: "cmdID:CMD:<command text>"
  let infoStr = `${cmdID}:CMD:${commandText}`;
  const encoder = new TextEncoder();
  const infoBytes = encoder.encode(infoStr); // No fixed-length padding/truncation
  const packet = new Uint8Array(header.length + infoBytes.length);
  packet.set(header, 0);
  packet.set(infoBytes, header.length);
  return { packet, cmdID };
}

        
function parseRspPacket(payload) {
  // Assume 'payload' is a Uint8Array containing the variable-length RSP info field.
  const decoder = new TextDecoder();
  const str = decoder.decode(payload).trim();
  
  // Expected new format: "cmdID:RSP:<status>:<message>"
  const parts = str.split(":", 4);
  if (parts.length < 4) {
    return { ok: false, error: "Incomplete RSP packet" };
  }
  const cmdID = parts[0];
  if (parts[1].toUpperCase() !== "RSP") {
    return { ok: false, error: "Not an RSP packet" };
  }
  const status = parseInt(parts[2], 10);
  if (isNaN(status)) {
    return { ok: false, error: "Invalid status value" };
  }
  const message = parts[3];
  return { ok: true, cmdID, status, message };
}

        
        // Optional: Send a CMD packet over the active connection and wait for its corresponding RSP.
        // This function uses a pending responses map to associate incoming responses with sent commands.
        const pendingCmdResponses = {};
        
        function sendCmd(commandText) {
          return new Promise((resolve, reject) => {
            // Read the callsigns from the UI fields.
            const myCallsign = document.getElementById('senderCallsign').value.trim();
            const fileServerCallsign = document.getElementById('receiverCallsign').value.trim();
            // Build the CMD packet.
            const { packet, cmdID } = buildCmdPacket(myCallsign, fileServerCallsign, commandText);
            // Wrap the packet in a KISS frame.
            const kissFrame = buildKissFrame(packet);
            
            // Store the promise resolvers keyed by the command ID.
            pendingCmdResponses[cmdID] = { resolve, reject, timestamp: Date.now() };
            
            // Send the frame via websockets or serial.
            if (document.getElementById('connectionType').value === 'websockets') {
              if (socket) socket.emit('raw_kiss_frame', kissFrame);
              else reject("No websocket connection available.");
            } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
              serialWriter.write(kissFrame).catch(err => reject(err));
            } else {
              reject("No valid connection available.");
            }
            
            // Optionally, set a timeout to reject the promise if no response arrives in time.
            const timeoutMS = (parseFloat(document.getElementById('timeoutSeconds').value) * 1000) || 10000;
            setTimeout(() => {
              if (pendingCmdResponses[cmdID]) {
                delete pendingCmdResponses[cmdID];
                reject("Timeout for CMD ID " + cmdID);
              }
            }, timeoutMS);
          });
        }
    
    function sendCmdWithRetry(commandText, maxRetries) {
      // If maxRetries isn't provided, read it from the "Timeout Retries" input box.
      maxRetries = maxRetries !== undefined ? maxRetries : (parseInt(document.getElementById('timeoutRetries').value, 10) || 3);
    
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const myCallsign = document.getElementById('senderCallsign').value.trim();
        const fileServerCallsign = document.getElementById('receiverCallsign').value.trim();
        const { packet, cmdID } = buildCmdPacket(myCallsign, fileServerCallsign, commandText);
    
        const sendCmdPacket = () => {
          attempts++;
          console.log(`Sending CMD attempt ${attempts}: ${commandText}`);
          // Store the promise resolvers under the fixed cmdID.
          pendingCmdResponses[cmdID] = { resolve, reject, timestamp: Date.now() };
          const kissFrame = buildKissFrame(packet);
          if (document.getElementById('connectionType').value === 'websockets') {
            if (socket) socket.emit('raw_kiss_frame', kissFrame);
            else reject("No websocket connection available.");
          } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
            serialWriter.write(kissFrame).catch(err => reject(err));
          } else {
            reject("No valid connection available.");
          }
        };
    
        const attemptSend = () => {
          sendCmdPacket();
          // Get timeout from the UI (in seconds) and convert to milliseconds.
          const timeoutMS = (parseFloat(document.getElementById('timeoutSeconds').value) * 1000) || 10000;
          setTimeout(() => {
            if (pendingCmdResponses[cmdID]) {
              if (attempts < maxRetries) {
                console.log(`No RSP within timeout. Retrying CMD "${commandText}" (attempt ${attempts + 1}/${maxRetries})`);
                attemptSend();
              } else {
                delete pendingCmdResponses[cmdID];
                reject(`No RSP after ${attempts} attempts.`);
              }
            }
          }, timeoutMS);
        };
    
        attemptSend();
      });
    }
    
        function openListFilesModal() {
          // Clear previous command, response text, and CSV table.
          document.getElementById('cmdSentList').innerText = "";
          document.getElementById('rspResponseList').innerText = "";
          document.getElementById('listTable').innerHTML = "";
        
          // Get a reference to the modal header and the modal title element.
          const modalHeader = document.querySelector('#listFiles .modal-header');
          const modalTitle = document.getElementById('listFilesLabel');
          
          // Check if the refresh button already exists.
          let refreshBtn = document.getElementById('refreshListBtn');
          if (!refreshBtn) {
            // Create the Refresh button.
            refreshBtn = document.createElement('button');
            refreshBtn.id = 'refreshListBtn';
            refreshBtn.className = 'btn btn-danger btn-sm ms-2';
            refreshBtn.innerText = 'Refresh List';
        refreshBtn.addEventListener('click', function() {
          // Clear the cached list and the table, then fetch a new list.
          this.style.display = 'none';
          cachedListCSV = null;
          document.getElementById('cmdSentList').innerText = "CMD: LIST"; // Set CMD text here
          document.getElementById('listTable').innerHTML = '<p>Waiting for file list...</p>';
          fetchListFiles();
        });
        
            // Insert the button immediately after the modal title so it appears next to the header text.
            modalTitle.insertAdjacentElement('afterend', refreshBtn);
          }
        
          // Only show the refresh button if we have cached content.
          if (cachedListCSV) {
            refreshBtn.style.display = 'inline-block';
          } else {
            refreshBtn.style.display = 'none';
          }
        
          // Show the modal.
          const listFilesModal = new bootstrap.Modal(document.getElementById('listFiles'));
          listFilesModal.show();
        
          // If a previous file list was received, reuse it; otherwise, fetch it.
          if (cachedListCSV) {
            processListFile(cachedListCSV);
          } else {
            document.getElementById('cmdSentList').innerText = "CMD: LIST";
            document.getElementById('listTable').innerHTML = '<p>Waiting for file list...</p>';
            fetchListFiles();
          }
        }
        
        
    function processListFile(csvText) {
      // Cache the CSV text so that we can reuse it on subsequent modal openings.
      cachedListCSV = csvText;
    
      // Split into lines and filter out empty ones.
      const lines = csvText.split('\n').filter(line => line.trim() !== '');
      if (lines.length === 0) return;
    
      // Build a search input box.
      let searchBoxHtml = `<input type="text" id="listSearchBox" class="form-control mb-3" placeholder="Search files...">`;
    
      // Build the table HTML.
      let tableHtml = '<div class="table-responsive"><table id="listFilesTable" class="table table-striped table-hover table-bordered"><thead><tr>';
      // Assume the first line is the header.
      const headers = lines[0].split(',');
      headers.forEach(header => {
        tableHtml += '<th>' + header.replace(/"/g, '') + '</th>';
      });
      tableHtml += '<th>Action</th></tr></thead><tbody>';
    
      // Process each subsequent row.
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',');
        if (cols.length < 3) continue;
        tableHtml += '<tr>';
        cols.forEach(col => {
          tableHtml += '<td>' + col.replace(/"/g, '') + '</td>';
        });
        // Use the file name from the first column (without quotes).
        const fileName = cols[0].replace(/"/g, '');
        tableHtml += '<td>';
        tableHtml += '<button class="btn btn-primary btn-sm" onclick="getFile(\'' + fileName + '\')">Get</button> ';
        tableHtml += '<button class="btn btn-warning btn-sm me-2" onclick="renameFile(\'' + fileName + '\')">Rename</button> ';
        tableHtml += '<button class="btn btn-danger btn-sm" onclick="deleteFile(\'' + fileName + '\')">Delete</button> ';
        tableHtml += '</td>';
        tableHtml += '</tr>';
      }
      tableHtml += '</tbody></table></div>';
    
      // Combine search box and table in the modal's listTable container.
      document.getElementById('listTable').innerHTML = searchBoxHtml + tableHtml;
    
      // Add search functionality.
    document.getElementById('listSearchBox').addEventListener('keyup', function () {
      const filter = this.value.toUpperCase();
      const table = document.getElementById('listFilesTable');
      const tr = table.getElementsByTagName('tr');
      // Skip the header row.
      for (let i = 1; i < tr.length; i++) {
        const firstCell = tr[i].getElementsByTagName('td')[0];
        if (firstCell) {
          let cellText = firstCell.textContent || firstCell.innerText;
          tr[i].style.display = cellText.toUpperCase().indexOf(filter) > -1 ? "" : "none";
        }
      }
    });  
    
    
      // Main table-sorting function that uses localeCompare for all columns.
      function sortTableByColumn(table, columnIndex, asc = true) {
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.querySelectorAll("tr"));
        rows.sort((a, b) => {
          const aText = a.children[columnIndex].textContent.trim();
          const bText = b.children[columnIndex].textContent.trim();
          return asc
            ? aText.localeCompare(
                bText,
                navigator.languages[0] || navigator.language,
                { numeric: true, ignorePunctuation: true }
              )
            : bText.localeCompare(
                aText,
                navigator.languages[0] || navigator.language,
                { numeric: true, ignorePunctuation: true }
              );
        });
        // Append the sorted rows back into the tbody.
        rows.forEach(row => tbody.appendChild(row));
      }
    
      // Attach click listeners to header cells (except the last "Action" column).
      const table = document.getElementById("listFilesTable");
      const headerCells = table.querySelectorAll("thead th");
      headerCells.forEach((th, index) => {
        // Skip the "Action" column (assumed to be the last header cell).
        if (index === headerCells.length - 1) return;
        th.style.cursor = 'pointer';
        // Use a data attribute to track the current sort order.
        th.setAttribute("data-sort-asc", "true");
        th.addEventListener("click", function() {
          let currentAsc = th.getAttribute("data-sort-asc") === "true";
          sortTableByColumn(table, index, currentAsc);
          // Toggle sort order for next click.
          th.setAttribute("data-sort-asc", (!currentAsc).toString());
        });
      });
    }
    
    
        
        
        // New function: when a Get button is clicked.
        function getFile(fileName) {
          // Hide the refresh button when the GET command is triggered.
          const refreshBtn = document.getElementById('refreshListBtn');
          if (refreshBtn) {
            refreshBtn.style.display = 'none';
          }
        
          // Update the modal's top CMD display.
          document.getElementById('cmdSentList').innerText = "CMD: GET " + fileName;
          // Clear any previous response and table.
          document.getElementById('rspResponseList').innerText = "";
          document.getElementById('listTable').innerHTML = "";
          
          // Send the GET command.
          sendCmd("GET " + fileName)
            .then(rsp => {
              const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
              document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
              
              // If the response indicates success, delay 1 second, then close the modal and scroll to the bottom.
              if (rsp.status === 1) {
    	    expectedFileId = rsp.cmdID;
    	    console.log("Expected file ID set to:", expectedFileId);
                setTimeout(() => {
  const modalEl = document.getElementById('listFiles');
  const modalInstance = bootstrap.Modal.getInstance(modalEl);
  if (modalInstance) {
    modalInstance.hide();
  }
  document.getElementById('receiverProgress').scrollIntoView({ behavior: 'smooth' });
}, 1000);
              }
            })
            .catch(err => {
              document.getElementById('rspResponseList').innerText = "Error: " + err;
            });
        }
        
        
        function fetchListFiles() {
          sendCmdWithRetry("LIST")
            .then(rsp => {
              const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
              document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
    	  if (rsp.status === 1) {
    		expectedFileId = rsp.cmdID;
    		console.log("Expected file ID for LIST set to:", expectedFileId);
    	  }
            })
            .catch(err => {
              document.getElementById('rspResponseList').innerText = "Error: " + err;
            });
        }
        function openCmdRspModal() {
          const modalEl = document.getElementById('cmdRspModal');
          const modalInstance = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
          modalInstance.show();
          return modalInstance;
        }
        
        function closeCmdRspModal() {
          const modalEl = document.getElementById('cmdRspModal');
          const modalInstance = bootstrap.Modal.getInstance(modalEl);
          if (modalInstance) {
            modalInstance.hide();
          }
        }
        function validateFileTransferInputs() {
          const sender = document.getElementById('senderCallsign').value.trim();
          const receiver = document.getElementById('receiverCallsign').value.trim();
          const fileInput = document.getElementById('fileInput');
          if (!sender || !receiver || !fileInput.files.length) {
            alert("Ensure your callsign, remote callsign and a file has been selected.");
            return null;
          }
          return { sender, receiver, file: fileInput.files[0] };
        }
        function configureBurstSettings() {
          if (document.getElementById('autoBurstCheckbox').checked) {
            burstSize = 0;
            currentDynamicBurstIndex = 2; // default to index 2 (i.e. burst size 4)
            currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
          } else {
            const sliderIndex = parseInt(document.getElementById('burstSlider').value, 10);
            burstSize = dynamicBurstSizes[sliderIndex];
          }
        }
        function prepareFileTransferData(file, compress, encodingMethod, fileId) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(e) {
              const arrayBuffer = e.target.result;
              const fileData = new Uint8Array(arrayBuffer);
              let finalData;
              try {
                finalData = compress ? pako.deflate(fileData, { level: 9 }) : fileData;
              } catch (err) {
                reject(err);
                return;
              }
              const md5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(fileData)).toString();
              const fileDataChunksCount = Math.ceil(finalData.length / CHUNK_SIZE);
              const totalPacketsExpected = fileDataChunksCount;
              
              // Read timeout values from UI
              const timeoutSeconds = parseFloat(document.getElementById('timeoutSeconds')?.value) || 5.0;
              const timeoutRetries = parseInt(document.getElementById('timeoutRetries')?.value, 10) || 5;
              
              // Build header string (fields separated by "|")
              const headerStr = timeoutSeconds + "|" +
                                timeoutRetries + "|" +
                                file.name + "|" +
                                fileData.length + "|" +
                                finalData.length + "|" +
                                md5 + "|" +
                                fileId + "|" +
                                (encodingMethod === 'base64' ? "1" : "0") + "|" +
                                (compress ? "1" : "0") + "|" +
                                (totalPacketsExpected + 1);
              const headerPayload = new TextEncoder().encode(headerStr);
              
              // Split the file data into chunks.
              const chunks = [];
              chunks.push(headerPayload); // packet 1 (header)
              for (let i = 0; i < fileDataChunksCount; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, finalData.length);
                let chunk = finalData.slice(start, end);
                if (encodingMethod === 'base64') {
                  let binaryString = "";
                  for (let j = 0; j < chunk.length; j++) {
                    binaryString += String.fromCharCode(chunk[j]);
                  }
                  let base64Str = btoa(binaryString);
                  chunk = new TextEncoder().encode(base64Str);
                }
                chunks.push(chunk);
              }
              
              resolve({
                fileDataChunks: chunks,
                totalPackets: chunks.length,
                md5,
                originalSize: fileData.length,
                compressedSize: finalData.length,
                timeoutSeconds,
                timeoutRetries
              });
            };
            reader.onerror = function(e) {
              reject(e);
            };
            reader.readAsArrayBuffer(file);
          });
        }
        function initiateFileTransfer(data, file, sender, receiver, fileId) {
          fileDataChunks = data.fileDataChunks;
          totalPackets = data.totalPackets;
          currentPacketIndex = 0;
          currentRetries = 0;
          totalRetries = 0;
          fileTransferInProgress = true;
          headerAckReceived = false;
          burstInProgress = false;
          missingPackets = [];
          highestPacketSentSoFar = 0;
          
          sentFileStats = {
            fileName: file.name,
            receiver: receiver,
            originalSize: data.originalSize,
            compressedSize: data.compressedSize,
            startTime: Date.now(),
            totalRetries: 0,
            bytesSent: 0,
            totalPackets: totalPackets,
            fileId: fileId
          };
          
          updateStatus(`File compressed from ${data.originalSize} bytes to ${data.compressedSize} bytes.
        File ID: ${fileId}`);
          updateSenderProgressUI();
          
          // Initialize header retry variables and send header packet (sequence 1)
          headerRetryCount = 0;
          headerAckReceived = false;
          headerSentTimestamp = Date.now();
          defaultHeaderTimeout = defaultPerPacketTimeout + (data.timeoutSeconds * 1000);
          console.log("Sending header packet (seq 1)");
          sendPacket(1);
          headerAckTimer = setTimeout(waitForHeaderAck, defaultHeaderTimeout);
        }
    
    
    function deleteFile(fileName) {
      const refreshBtn = document.getElementById('refreshListBtn');
      if (refreshBtn) {
        refreshBtn.style.display = 'none';
      }
      if (confirm("Are you sure you want to delete " + fileName + "?")) {
        // Update the modal's command display.
        document.getElementById('cmdSentList').innerText = "CMD: DEL " + fileName;
        // Clear previous response and table.
        document.getElementById('rspResponseList').innerText = "";
        document.getElementById('listTable').innerHTML = "";
        
        // Send the DEL command.
        sendCmd("DEL " + fileName)
          .then(rsp => {
            const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
            document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
            // If successful, show "Waiting for file list..." and then refresh.
            if (rsp.status === 1) {
              setTimeout(() => {
                document.getElementById('listTable').innerHTML = '<p>Refreshing file list...</p>';
                fetchListFiles();
              }, 1000);
            }
          })
          .catch(err => {
            document.getElementById('rspResponseList').innerText = "Error: " + err;
          });
      }
    }
    
    function renameFile(fileName) {
      const refreshBtn = document.getElementById('refreshListBtn');
      if (refreshBtn) {
        refreshBtn.style.display = 'none';
      }
      const newName = prompt("Enter new filename for " + fileName + ":", fileName);
      if (newName && newName.trim() !== "" && newName !== fileName) {
        // Update the modal's command display.
        document.getElementById('cmdSentList').innerText = "CMD: REN " + fileName + "|" + newName;
        // Clear previous response and table.
        document.getElementById('rspResponseList').innerText = "";
        document.getElementById('listTable').innerHTML = "";
        
        // Send the REN command.
        sendCmd("REN " + fileName + "|" + newName)
          .then(rsp => {
            const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
            document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
            // If successful, show "Waiting for file list..." and then refresh.
            if (rsp.status === 1) {
              setTimeout(() => {
                document.getElementById('listTable').innerHTML = '<p>Refreshing file list...</p>';
                fetchListFiles();
              }, 1000);
            }
          })
          .catch(err => {
            document.getElementById('rspResponseList').innerText = "Error: " + err;
          });
      } else {
        alert("Invalid new filename.");
      }
    }
    
    
    function updateListFilesButtonStatus() {
      const sender = document.getElementById('senderCallsign').value.trim();
      const receiver = document.getElementById('receiverCallsign').value.trim();
      const listBtn = document.getElementById('listFilesBtn');
      let connectionIsActive = false;
      
      if (document.getElementById('connectionType').value === 'websockets') {
        connectionIsActive = (socket && socket.connected);
      } else {
        connectionIsActive = serialConnected;
      }
      
      // Disable if callsigns are missing or if there's no active connection.
      if (listBtn) {
        listBtn.disabled = !(sender && receiver && connectionIsActive);
      }
    }
    
    function generateTwoCharID() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      return chars.charAt(Math.floor(Math.random() * chars.length)) +
             chars.charAt(Math.floor(Math.random() * chars.length));
    }

window.viewReceivedFile = function(fileId) {
  const file = persistentReceivedFiles.find(f => f.fileId === fileId);
  if (!file) return;
  
  // Ensure it's a text file.
  if (!file.fileName.toLowerCase().endsWith('.txt')) {
    alert("The selected file is not a text file.");
    return;
  }
  
  // Store the file for later editing.
  currentViewedFile = file;
  
  // Fetch the text content from the dataUrl.
  fetch(file.dataUrl)
    .then(response => response.text())
    .then(text => {
      document.getElementById('fileViewContent').innerText = text;
      const modal = new bootstrap.Modal(document.getElementById('fileViewModal'));
      modal.show();
    })
    .catch(err => {
      console.error("Error loading file content:", err);
    });
};

// Open the modal when the Create Text File button is clicked.
document.getElementById('createTextFileBtn').addEventListener('click', function() {
    const modal = new bootstrap.Modal(document.getElementById('createTextFileModal'));
    modal.show();
});

// When the modal's Send File button is clicked, create a text file and send it.
document.getElementById('modalSendFileBtn').addEventListener('click', function() {
    const senderInput = document.getElementById('senderCallsign').value.trim();
    const receiverInput = document.getElementById('receiverCallsign').value.trim();
    const fileNameInput = document.getElementById('textFileName').value.trim();
    const fileContent = document.getElementById('textFileContent').value;
    
    if (!senderInput || !receiverInput || !fileNameInput || !fileContent) {
        alert("Provide filename and content.");
        return;
    }
    
    // Append .txt if not already present.
    let finalFileName = fileNameInput;
    if (!finalFileName.toLowerCase().endsWith('.txt')) {
       finalFileName += '.txt';
    }
    
    // Create a File object from the content.
    const file = new File([fileContent], finalFileName, { type: 'text/plain' });
    
    if (fileTransferInProgress) {
        alert("A file transfer is already in progress.");
        return;
    }
    
    // Disable the main Send File button.
    document.getElementById('sendFileBtn').disabled = true;
    
    // Set global sender and receiver.
    sender = senderInput;
    receiver = receiverInput;
    
    // Get options from UI.
    const compress = document.getElementById('compressCheckbox').checked;
    const encodingMethod = document.getElementById('encodingMethod').value;
    
    // Configure burst settings (reuse your existing function).
    configureBurstSettings();
    
    // Branch based on whether File Server mode is enabled.
    if (document.getElementById('isFileServer').checked) {
        const cmdModal = openCmdRspModal();
        document.getElementById('cmdSentCmdRsp').innerText = "CMD: PUT " + finalFileName;
        document.getElementById('rspResponseCmdRsp').innerText = "";
        
        sendCmdWithRetry("PUT " + finalFileName)
          .then(rsp => {
             document.getElementById('rspResponseCmdRsp').innerText =
                "RSP: " + (rsp.status === 1 ? "Success" : "Failure") + " - " + rsp.message;
             if (rsp.status === 1) {
                 fileId = rsp.cmdID;
                 setTimeout(() => {
                     closeCmdRspModal();
                     document.getElementById('senderProgress').scrollIntoView({ behavior: 'smooth' });
                     startTransfer(fileId);
                     prepareFileTransferData(file, compress, encodingMethod, fileId)
                       .then(data => {
                           initiateFileTransfer(data, file, sender, receiver, fileId);
                       })
                       .catch(err => {
                           updateStatus("Error reading file: " + err);
                           document.getElementById('sendFileBtn').disabled = false;
                       });
                 }, 1000);
             } else {
                 document.getElementById('sendFileBtn').disabled = false;
             }
          })
          .catch(err => {
             document.getElementById('rspResponseCmdRsp').innerText = "Error: " + err;
             document.getElementById('sendFileBtn').disabled = false;
          });
    } else {
        // Normal file transfer branch.
        fileId = generateTwoCharID();
        startTransfer(fileId);
        prepareFileTransferData(file, compress, encodingMethod, fileId)
          .then(data => {
              initiateFileTransfer(data, file, sender, receiver, fileId);
          })
          .catch(err => {
              updateStatus("Error reading file: " + err);
              document.getElementById('sendFileBtn').disabled = false;
          });
    }
    
    // Hide the modal once the file transfer is initiated.
    const modalEl = document.getElementById('createTextFileModal');
    const modalInstance = bootstrap.Modal.getInstance(modalEl);
    if (modalInstance) {
        modalInstance.hide();
    }
});

document.getElementById('clearTextFileBtn').addEventListener('click', function() {
  document.getElementById('textFileName').value = '';
  document.getElementById('textFileContent').value = '';
});

document.getElementById('editFileBtn').addEventListener('click', function() {
  // Get the current text content.
  const fileContent = document.getElementById('fileViewContent').innerText;
  
  if (!currentViewedFile) {
    alert("No file loaded to edit.");
    return;
  }
  
  // Pre-populate the create text file modal fields.
  let fileName = currentViewedFile.fileName.replace(/\.txt$/i, '');
  document.getElementById('textFileName').value = fileName;
  document.getElementById('textFileContent').value = fileContent;
  
  // Close the current (view) modal.
  const viewModalEl = document.getElementById('fileViewModal');
  const viewModalInstance = bootstrap.Modal.getInstance(viewModalEl);
  if (viewModalInstance) {
    viewModalInstance.hide();
  }
  
  // Open the create text file modal.
  const createModal = new bootstrap.Modal(document.getElementById('createTextFileModal'));
  createModal.show();
});
            </script>
            <footer style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/madpsy/kiss-tnc-file-transfer" target="_blank">Github Repo</a>
            </footer>

</body>

</html>