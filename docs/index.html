<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>KISS File Transfer</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="bootstrap.min.css" rel="stylesheet">
    <script src="socket.io.min.js"></script>
    <script src="crypto-js.min.js"></script>
    <script src="pako.min.js"></script>
    <script src="bootstrap.bundle.min.js"></script>
    <style>
        body { padding: 20px; }
        #status { margin-top: 1rem; font-weight: bold; }
        .progress { height: 20px; margin-bottom: 10px; }
        .inline-control { display: inline-block; vertical-align: middle; margin-left: 20px; }
        #connectionStatusDot {
          display: inline-block;
          width: 15px;
          height: 15px;
          border-radius: 50%;
          background-color: red;
          margin-left: 10px;
        }
.modal-dialog {
  display: table;
  width: auto;
  max-width: none;
}

#createTextFileModal .modal-dialog {
  display: block; /* or remove this line if not needed */
  max-width: 800px; /* Adjust width as needed */
  margin: 30px auto; /* Center the modal */
}
#fileViewModal .modal-dialog {
  display: block; /* or remove this line if not needed */
  max-width: 800px; /* Adjust width as needed */
  margin: 30px auto; /* Center the modal */
}

#webViewModal .modal-dialog {
  display: block; /* or remove this line if not needed */
  max-width: 1000px; /* Adjust width as needed */
  margin: 30px auto; /* Center the modal */
}

#webViewModal .modal-content {
    border: 1px solid #ccc; /* Adds a light grey border */
}

#webViewModal .modal-body {
    padding: 15px;          /* Adds internal padding */
    overflow-y: auto;       /* Enables vertical scrolling if content overflows */
}
  .spinner {
    border: 8px solid #f3f3f3;
    border-top: 8px solid #3498db;
    border-radius: 50%;
    width: 60px;
    height: 60px;
    animation: spin 2s linear infinite;
    margin: 2rem auto;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

/* Back and Forward: Blue */
#navBackBtn,
#navForwardBtn {
  background-color: #007bff;
  border-color: #007bff;
  color: #fff;
}

#navBackBtn:hover,
#navForwardBtn:hover {
  background-color: #0056b3;
  border-color: #004085;
}

/* Home: Yellow */
#navHomeBtn {
  background-color: #ffc107;
  border-color: #ffc107;
  color: #000;
}

#navHomeBtn:hover {
  background-color: #e0a800;
  border-color: #d39e00;
}

/* Refresh: Red */
#navRefreshBtn {
  background-color: #dc3545;
  border-color: #dc3545;
  color: #fff;
}

#navRefreshBtn:hover {
  background-color: #c82333;
  border-color: #bd2130;
}
    </style>
</head>

<body>
    <div class="container">
        <h1>KISS File Transfer <span id="connectionStatusDot"></span></h1>
        <div class="dropdown" style="position: absolute; top: 20px; right: 20px; z-index: 1000;">
            <button class="btn btn-secondary dropdown-toggle" type="button" id="helpMenuButton" data-bs-toggle="dropdown" aria-expanded="false">
	    Help
	  </button>
            <ul class="dropdown-menu dropdown-menu-end" aria-labelledby="helpMenuButton">
                <li><a class="dropdown-item" href="https://github.com/madpsy/kiss-tnc-file-transfer/" target="_blank">Github Repo</a></li>
                <li><a class="dropdown-item" href="help/readme-protocol.html" target="_blank">Protocol Spec</a></li>
                <li><a class="dropdown-item" href="help/readme-fileserver.html" target="_blank">File Server</a></li>
                <li><a class="dropdown-item" href="help/readme-fileserverclient.html" target="_blank">File Server Client</a></li>
                <li><a class="dropdown-item" href="help/readme-websockets.html" target="_blank">Websockets Server</a></li>
                <li><a class="dropdown-item" href="help/readme-sender.html" target="_blank">Sender</a></li>
                <li><a class="dropdown-item" href="help/readme-receiver.html" target="_blank">Receiver</a></li>
                <li><a class="dropdown-item" href="help/readme-repeater.html" target="_blank">Repeater</a></li>
                <li><a class="dropdown-item" href="help/readme-bridge.html" target="_blank">Bridge</a></li>
                <li><a class="dropdown-item" href="help/readme-passthrough.html" target="_blank">TNC Passthrough</a></li>
                <li><a class="dropdown-item" href="help/readme-monitor.html" target="_blank">Monitor Utility</a></li>
            </ul>
        </div>
        <div class="mb-3">
            <label for="connectionType" class="form-label">Connection Type</label> <select id="connectionType" class="form-select">
        <option value="serial" selected>
          Serial
        </option>
        <option value="websockets">
          Websockets
        </option>
      </select>
        </div>
        <div id="serialSettings" style="display: none;">
            <div class="mb-3">
                <label for="baudRate" class="form-label">Baud Rate</label> <select id="baudRate" class="form-select">
          <option value="9600">
            9600
          </option>
          <option value="14400">
            14400
          </option>
          <option value="19200">
            19200
          </option>
          <option value="38400">
            38400
          </option>
          <option value="57600">
            57600
          </option>
          <option value="115200" selected>
            115200
          </option>
        </select>
            </div><button id="serialConnectBtn" class="btn btn-primary">Connect</button> <button id="serialDisconnectBtn" class="btn btn-secondary" style="display: none;">Disconnect</button>
        </div><br>
        <div class="mb-3">
            <label for="senderCallsign" class="form-label">Your Callsign*</label> <input type="text" id="senderCallsign" class="form-control" placeholder="Enter your callsign">
        </div>
        <div class="mb-3">
            <label for="receiverCallsign" class="form-label">Remote Callsign</label> <input type="text" id="receiverCallsign" class="form-control" placeholder="Enter remote callsign">
        </div>
        <div class="mb-3">
            <div class="form-check">
                <input type="checkbox" class="form-check-input" id="restrictCallsign" checked>
                <label class="form-check-label" for="restrictCallsign">Only accept files from this callsign</label>
            </div>
            <div class="form-check">
                <input type="checkbox" class="form-check-input" id="isFileServer">
                <label class="form-check-label" for="isFileServer">Is a file server?</label>
            </div>
            <!-- Container where the List button will be added dynamically -->
            <span id="listButtonContainer"></span>
        </div>
	<div class="mb-3" id="pathSection" style="display: none;">
	  <label for="pathInput" class="form-label">Path for Send File</label>
	  <div class="input-group">
	    <input type="text" id="pathInput" class="form-control" placeholder="Optional directory path to Send File">
	    <button id="createDirectoryBtn" class="btn btn-primary ms-1">Create Path</button>
	  </div>
	</div>
        <div class="mb-3">
            <label for="fileInput" class="form-label">File to Send</label> <input type="file" id="fileInput" class="form-control">
        </div>

        <!-- Toggle button for Advanced Settings -->
        <button class="btn btn-link" type="button" data-bs-toggle="collapse" data-bs-target="#advancedSettings" aria-expanded="false" aria-controls="advancedSettings">
  Advanced Settings
</button>

        <!-- Collapsible Advanced Settings Section -->
        <div class="collapse" id="advancedSettings">

            <div class="card card-body">
                <div class="mb-3">
                    <label for="encodingMethod" class="form-label">Encoding Method</label> <select id="encodingMethod" class="form-select">
        <option value="binary" selected>
          Binary (fastest)
        </option>
        <option value="base64">
          Base64 (max compatibility)
        </option>
      </select>
                </div>
                <!-- Timeout Seconds -->
                <div class="mb-3">
                    <label for="timeoutSeconds" class="form-label">Timeout Seconds</label>
                    <input type="number" id="timeoutSeconds" class="form-control" value="5" step="1">
                </div>
                <!-- Timeout Retries -->
                <div class="mb-3">
                    <label for="timeoutRetries" class="form-label">Timeout Retries</label>
                    <input type="number" id="timeoutRetries" class="form-control" value="3" step="1">
                </div>
                <!-- Compress and Window Size -->
                <div class="mb-3">
                    <div class="form-check">
                        <input type="checkbox" class="form-check-input" id="compressCheckbox" checked>
                        <label class="form-check-label" for="compressCheckbox">Compress</label>
                    </div>
                    <div class="inline-control">
                        <label for="burstSlider" class="form-label" style="margin-bottom: 0;">
          Window Size: <span id="burstValue">4</span>
        </label>
                        <input type="range" class="form-range" id="burstSlider" min="0" max="5" step="1" value="2">
                    </div>
                    <div class="inline-control">
                        <div class="form-check" style="margin-left: 10px;">
                            <input type="checkbox" class="form-check-input" id="autoBurstCheckbox" checked> <label class="form-check-label" for="autoBurstCheckbox">Auto</label>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="mb-3">
            <div class="mb-3">
                <button id="sendFileBtn" class="btn btn-primary">Send File</button>
                <button id="createTextFileBtn" class="btn btn-primary">Create Text File</button>
                <div id="status"></div>
            </div>
            <div id="status"></div>
            <hr>
            <h2>Sender Progress</h2>
            <div id="senderProgress">
                <p>No file being sent.</p>
            </div>
            <hr>
            <h2>Sent Files</h2>
            <div id="sentFiles">
                <p>No files sent yet.</p>
            </div>
            <hr>
            <h2>Receiver Progress</h2>
            <div id="receiverProgress">
                <p>No active transfers.</p>
            </div>
            <hr>
            <h2>Received Files</h2>
            <div id="receivedFiles">
                <p>No files received yet.</p>
            </div>
            <div class="modal fade" id="listFiles" tabindex="-1" aria-labelledby="listFilesLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="listFilesLabel">File Server</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Rename these IDs for the list modal -->
                            <div id="cmdSentList"></div>
                            <div id="rspResponseList"></div>
                            <br>
                            <div id="listTable"></div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="cmdRspModal" tabindex="-1" aria-labelledby="cmdRspModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="cmdRspModalLabel">File Server</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <!-- Rename these IDs for the CMD/RSP modal -->
                            <div id="cmdSentCmdRsp"></div>
                            <div id="rspResponseCmdRsp"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal fade" id="fileViewModal" tabindex="-1" aria-labelledby="fileViewModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="fileViewModalLabel">View File</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <pre id="fileViewContent" class="form-control" style="white-space: pre-wrap; height: 300px; overflow: auto; resize: vertical;"></pre>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                            <button id="editFileBtn" type="button" class="btn btn-primary">Edit</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="createTextFileModal" tabindex="-1" aria-labelledby="createTextFileModalLabel" aria-hidden="true">
                <div class="modal-dialog">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title" id="createTextFileModalLabel">Create Text File</h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                        </div>
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="textFileName" class="form-label">Filename</label>
                                <div class="input-group">
                                    <input type="text" id="textFileName" class="form-control" placeholder="Enter file name and select extension">
                                    <select id="textFileExtension" class="form-select" style="max-width: 100px;">
				    <option value=".txt" selected>.txt</option>
				    <option value=".html">.html</option>
				    <option value=".js">.js</option>
				    <option value=".css">.css</option>
				  </select>
                                </div>

                            </div>
                            <div class="mb-3">
                                <label for="textFileContent" class="form-label">Content</label>
                                <textarea id="textFileContent" class="form-control" rows="10" placeholder="Type your text here..."></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button id="clearTextFileBtn" type="button" class="btn btn-warning">Clear</button>
                            <button id="modalSendFileBtn" type="button" class="btn btn-primary">Send File</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="modal fade" id="webViewModal" tabindex="-1" aria-labelledby="webViewModalLabel" aria-hidden="true">
                <div class="modal-dialog modal-lg">
                    <div class="modal-content">
                        <!-- Navigation header -->
                        <!-- Navigation header -->
                        <div class="modal-header" style="display: flex; align-items: center; justify-content: flex-start;">
                            <button id="navBackBtn" class="btn btn-sm btn-custom-nav" style="margin-right: 5px;" title="Back">&#x2190;</button>
                            <button id="navForwardBtn" class="btn btn-sm btn-custom-nav" style="margin-right: 5px;" title="Forward">&#x2192;</button>
                            <button id="navHomeBtn" class="btn btn-sm btn-custom-nav" style="margin-right: 5px;" title="Home">&#x2302;</button>

                            <div style="display: flex; align-items: center;">
                                <button id="navRefreshBtn" class="btn btn-sm btn-custom-nav" style="margin-right: 10px;" title="Refresh">&#10227;</button>
                                <!-- Changed input: removed readonly and doubled max-width -->
                                <input type="text" id="currentPageUrl" class="form-control" placeholder="Current page" style="width: 450px;">
                                <!-- New Go! button -->
                                <button id="goBtn" class="btn btn-success btn-sm" style="margin-left: 5px;">Go!</button>
                            </div>
                        </div>

                        <!-- Modal body for content -->
                        <div class="modal-body" id="webViewContent" style="min-height: 500px; overflow:auto; padding: 10px;">
                            <div id="spinnerContainer">
                                <div class="spinner"></div>
                            </div>
                        </div>
                        <div class="modal-footer" style="display: flex; justify-content: space-between; align-items: center;">
  				<button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
				  <div id="modalDownloadProgress" style="display: flex; align-items: center;">
				   <span id="modalDownloadFilename" style="margin-right: 10px; font-weight: bold;"></span>
				   <div class="progress" style="width: 200px; margin-bottom: 0;">
			             <div class="progress-bar bg-primary" id="modalDownloadProgressBar" role="progressbar" style="width: 0%;">0%</div>
			         </div>
			    </div>
			</div>
                    </div>
                </div>
            </div>

            <script>
                /***********************
                 * Global Variables
                 ***********************/
                let activeTransfers = {};
                let completedTransfers = {};
                let socket = null;
                let serialPort = null, serialWriter = null, serialReader = null, stopReading = false;
                let serialConnected = false;
                let kissBuffer = new Uint8Array(0);
                
                // Sender globals
                let maxRetries = parseInt(document.getElementById('timeoutRetries').value, 10) || 3;
                let burstSize = 4; // if auto mode is off; if auto then burstSize === 0
                let currentPacketIndex = 0;
                let currentRetries = 0, totalRetries = 0;
                let fileTransferInProgress = false, ackTimer = null, sentFileStats = null;
                const CHUNK_SIZE = 227;
                let headerAckReceived = false; // whether header ACK has been received
                let burstInProgress = false;
                let lastRangeAck = "";
                let duplicateAckCount = 0;
                let missingPackets = [];
                
                let fileDataChunks = [];
                let totalPackets = 0;
                
                // Sender/receiver identifiers
                let sender = "";
                let receiver = "";
                let fileId = "";
                let cachedListCSV = null;
                let expectedFileId = null;
                
                // Dynamic burst mode settings (allowed sizes: 1,2,4,6,8,10)
                const dynamicBurstSizes = [1, 2, 4, 6, 8, 10];
                let currentDynamicBurstIndex = 2; // default to 4 (index 2)
                let currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
                let consecutiveSuccessCount = 0;
                
                // Header retry and per-packet timing globals
                let headerSentTimestamp = 0;
                let headerAckTimer = null;
                let headerRetryCount = 0;
                const defaultPerPacketTimeout = 1500; // in milliseconds
                let perPacketTimeout = defaultPerPacketTimeout; // updated after header ACK arrives
                let defaultHeaderTimeout = 0; // computed based on timeoutSeconds
                
                // NEW: Variables to record burst timing for per-packet timeout update
                let burstStartTimestamp = 0;
                let lastBurstSentCount = 0; // actual number of packets sent in the burst
		let dataRetryCount = 0;
		let currentBurstId = 0;
                
                // NEW: FIN-ACK retry loop variables – these are read from the UI.
                let finalAckRetryTimer = null;
                let currentFinAckRetryCount = 0;
                let waitingForFinAck = false;
                let maxFinalAckRetries = 0;  // from UI (#timeoutRetries)
                let finalAckTimeout = 0;     // from UI (#timeoutSeconds * 1000)
                let waitingForFinAckMap = {};
                let currentFileId = null;
                
                // Sender state display variables
                let senderState = "Sending";
                let senderStateTimestamp = 0;

		let currentViewedFile = null;
                
                // Track highest packet sequence number sent so far
                let highestPacketSentSoFar = 0;  

		let cachedIndexHTML = null;
		let currentPageName = "index.html";
		let autoSaveFilesEnabled = true;
		let pageHistory = [];	
		let historyIndex = -1;

		const pendingGETs = {};                

                /***********************
                 * Persistence Functions
                 ***********************/
            window.addEventListener("error", (event) => {
		  console.error("Global error or uncaught exception:", event.error);
	    });

function getMaxRetries() {
  return parseInt(document.getElementById('timeoutRetries').value, 10) || 3;
}

              function waitForHeaderAck() {
              if (headerAckReceived) return; // Header ACK was received, so no need to wait further.
              headerRetryCount++;
              const timeoutRetries = parseInt(document.getElementById('timeoutRetries')?.value, 10) || 5;
              if (headerRetryCount > timeoutRetries) {
                updateStatus("No header ACK received after maximum retries. Aborting file transfer.");
                cancelSenderTransfer();
                return;
              }
              updateStatus("Timeout waiting for header ACK. Retrying header packet (retry " + headerRetryCount + " of " + timeoutRetries + ").");
              console.log("Resending header packet (seq 1) due to header ACK timeout, retry " + headerRetryCount);
              sendPacket(1);
              headerSentTimestamp = Date.now();
              // Increase the timeout for the next retry (exponential backoff)
              let newTimeout = defaultHeaderTimeout * Math.pow(1.5, headerRetryCount);
              headerAckTimer = setTimeout(waitForHeaderAck, newTimeout);
              }
            
            
                function saveReceivedFilesToLocalStorage(filesArray) {
                  try { localStorage.setItem("receivedFiles", JSON.stringify(filesArray)); }
                  catch (e) { console.error("Error saving received files:", e); }
                }
                function loadReceivedFilesFromLocalStorage() {
                  const data = localStorage.getItem("receivedFiles");
                  if (data) {
                    try { return JSON.parse(data); }
                    catch (e) { console.error("Error parsing received files:", e); }
                  }
                  return [];
                }
                function saveSentFilesToLocalStorage(filesArray) {
                  try { localStorage.setItem("sentFiles", JSON.stringify(filesArray)); }
                  catch (e) { console.error("Error saving sent files:", e); }
                }
                function loadSentFilesFromLocalStorage() {
                  const data = localStorage.getItem("sentFiles");
                  if (data) {
                    try { return JSON.parse(data); }
                    catch (e) { console.error("Error parsing sent files:", e); }
                  }
                  return [];
                }
                
                let persistentReceivedFiles = loadReceivedFilesFromLocalStorage();
                let persistentSentFiles = loadSentFilesFromLocalStorage();
                
                /***********************
                 * UI Update Functions
                 ***********************/
                function updateReceivedFilesUI() {
  const container = document.getElementById('receivedFiles');
  // Filter out any file with the name "LIST.txt"
  const filteredFiles = persistentReceivedFiles.filter(file => file.fileName.trim() !== "LIST.txt");
  if (!filteredFiles.length) {
    container.innerHTML = "<p>No files received yet.</p>";
    return;
  }
  let html = `<table class="table table-striped">
    <thead>
      <tr>
        <th>Date/Time</th>
        <th>Sender</th>
        <th>File Name</th>
        <th>ID</th>
        <th>Original</th>
        <th>Compressed</th>
        <th>Time (s)</th>
        <th>Speed (B/s)</th>
        <th>Duplicates</th>
        <th>MD5</th>
        <th></th>
        <th></th>
      </tr>
    </thead>
    <tbody>`;
  filteredFiles.forEach((file) => {
    let checksumIcon = file.checksumMatch
      ? '<span style="color:green;">&#10004;</span>'
      : '<span style="color:red;">&#10008;</span>';
    let elapsedSec = file.elapsed / 1000;
    let speed = elapsedSec > 0 ? Math.floor((file.bytesReceived || file.size) / elapsedSec) : 0;
    let dupPercent = file.totalPackets ? Math.round((file.duplicates / file.totalPackets) * 100) : "0";
    
    // Only add a "View" button if the file extension is ".txt"

    const editableExtensions = ['.txt', '.html', '.js', '.css'];
    const lowerName = file.fileName.toLowerCase();
    let actionButton;
    if (editableExtensions.some(ext => lowerName.endsWith(ext))) {
      // For these files, show an "Edit" button.
      actionButton = `<button class="btn btn-success btn-sm" onclick="viewReceivedFile('${file.fileId}')">View</button>`;
    } else {
      // For other file types, continue showing a "Download" button.
      actionButton = `<button class="btn btn-success btn-sm" onclick="downloadReceivedFile('${file.fileId}')">Download</button>`;
     }
    
    html += `<tr>
      <td>${new Date(file.timestamp).toLocaleString()}</td>
      <td>${file.sender}</td>
      <td>${file.fileName}</td>
      <td>${file.fileId}</td>
      <td>${file.originalSize} bytes</td>
      <td>${file.compressedSize} bytes</td>
      <td>${elapsedSec.toFixed(2)}</td>
      <td>${speed}</td>
      <td>${file.duplicates} (${dupPercent}%)</td>
      <td>${checksumIcon}</td>
      <td>${actionButton}</td>
      <td><button class="btn btn-danger btn-sm" onclick="deleteReceivedFileById('${file.fileId}')">Remove</button></td>
    </tr>`;
  });
  
  html += `</tbody></table>
    <button id="removeAllBtn" class="btn btn-danger mt-2" onclick="removeAllReceivedFiles()">Remove All</button>`;
  container.innerHTML = html;
}

    
    function deleteReceivedFileById(fileId) {
      persistentReceivedFiles = persistentReceivedFiles.filter(file => file.fileId !== fileId);
      saveReceivedFilesToLocalStorage(persistentReceivedFiles);
      updateReceivedFilesUI();
    }  
                
function updateSentFilesUI() {
  const container = document.getElementById('sentFiles');
  if (!persistentSentFiles.length) {
    container.innerHTML = "<p>No files sent yet.</p>";
    return;
  }
  let html = `<table class="table table-striped">
    <thead>
      <tr>
        <th>Date/Time</th>
        <th>Receiver</th>
        <th>File Name</th>
        <th>Original Size</th>
        <th>Compressed Size</th>
        <th>Retries</th>
        <th>Total Time (s)</th>
        <th>Speed (Bytes/s)</th>
        <th>Clear</th>
      </tr>
    </thead>
    <tbody>`;
  persistentSentFiles.forEach((stat, index) => {
    let totalTime = parseFloat(stat.totalTime);
    let speed = totalTime > 0 ? Math.floor(stat.bytesSent / totalTime) : 0;
    html += `<tr>
      <td>${new Date(stat.timestamp).toLocaleString()}</td>
      <td>${stat.receiver || ""}</td>
      <td>${stat.fileName}</td>
      <td>${stat.originalSize} bytes</td>
      <td>${stat.compressedSize} bytes</td>
      <td>${stat.totalRetries}</td>
      <td>${stat.totalTime}</td>
      <td>${speed}</td>
      <td><button class="btn btn-warning btn-sm" onclick="clearSentFile(${index})">Clear</button></td>
    </tr>`;
  });
  html += `</tbody></table>
    <button id="clearAllSentBtn" class="btn btn-warning mt-2" onclick="clearAllSentFiles()">Clear All</button>`;
  container.innerHTML = html;
}

                
function updateReceiverProgressUI() {
  const container = document.getElementById('receiverProgress');
  if (Object.keys(activeTransfers).length === 0) {
    container.innerHTML = "<p>No active transfers.</p>";
    return;
  }
  let html = "";
  const now = Date.now();
  for (let key in activeTransfers) {
    let transfer = activeTransfers[key];

    // Total packets expected for this transfer.
    const total = transfer.totalChunks || 1;

    // 'cumulative' is the last contiguous packet number received.
    const cumulative = transfer.lastAcked || 1;

    // Calculate burst window progress.
    let burstBlue = 0;   // number of packets in the current burst that have been received
    let burstOrange = 0; // number of packets still expected in the current burst
    if (transfer.currentBurstTo && transfer.currentBurstTo > cumulative) {
      const burstWindowSize = transfer.currentBurstTo - cumulative;
      // Count received packets in the burst window.
      for (let seq = cumulative + 1; seq <= transfer.currentBurstTo; seq++) {
        if (transfer.received[seq]) {
          burstBlue++;
        }
      }
      burstOrange = burstWindowSize - burstBlue;
    }
    // Overall blue portion is the cumulative plus burst packets received.
    const blueTotal = cumulative + burstBlue;
    // Calculate percentages relative to total packets.
    const bluePercent = Math.floor((blueTotal / total) * 100);
    const orangePercent = Math.floor((burstOrange / total) * 100);

    // Build the dual-segment progress bar.
    let progressBarHTML = `
      <div class="progress mb-2" style="height: 20px;">
        <div class="progress-bar bg-primary" role="progressbar"
             style="width: ${bluePercent}%;" aria-valuenow="${bluePercent}"
             aria-valuemin="0" aria-valuemax="100">
          ${bluePercent > 0 ? bluePercent + '%' : ''}
        </div>
        <div class="progress-bar bg-warning" role="progressbar"
             style="width: ${orangePercent}%;" aria-valuenow="${orangePercent}"
             aria-valuemin="0" aria-valuemax="100">
          ${orangePercent > 0 ? orangePercent + '%' : ''}
        </div>
      </div>
    `;

    // Calculate elapsed time in seconds.
    const elapsed = (now - transfer.startTime) / 1000;
    // Track bytes received.
    const bytesReceived = transfer.rawBytesReceived || 0;
    // Expected total size from header.
    const expectedBytes = transfer.header ? transfer.header.compressedSize : 0;
    // Calculate transfer rate in bytes per second.
    const transferRate = elapsed > 0 ? Math.floor(bytesReceived / elapsed) : 0;
    // Calculate ETA.
    let eta = "N/A";
    if (transferRate > 0 && expectedBytes) {
      eta = ((expectedBytes - bytesReceived) / transferRate).toFixed(2) + " s";
    }
    // Build the stats line using the desired format.
    let statsLine = `Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} (${transferRate} bytes/sec)`;

    // Determine the receiving/ACK status.
    const statusText = (transfer.lastAckTime && (now - transfer.lastAckTime < 1000))
      ? '<span style="color: orange; font-weight: bold;">Sending ACK</span>'
      : '<span style="color: green; font-weight: bold;">Receiving</span>';

    // Build the original/compressed size line (if header available).
    let sizeLine = "";
    if (transfer.header) {
      sizeLine = `<p style="margin-bottom: 2px;">Original Size: ${transfer.header.originalSize} bytes; Compressed Size: ${transfer.header.compressedSize} bytes</p>`;
    }

    // Build the UI for this transfer.
    html += `
      <div class="mb-2 border p-2">
        <h5>From ${key.split("_")[0]} – ${transfer.header ? transfer.header.fileName : "Unknown file"} (ID: ${transfer.header ? transfer.header.fileId : "N/A"})</h5>

        <h5>${blueTotal} of ${total} packets received</h5>
        ${sizeLine}
        ${progressBarHTML}
        <p style="margin-bottom: 2px;">Status: ${statusText}</p>
        <p style="margin-top: 2px;">${statsLine}</p>
        <div style="margin-top: 0.5rem;">
          <button class="btn btn-danger btn-sm" onclick="cancelReceiverTransfer('${key}')">Cancel</button>
        </div>
      </div>
    `;
  }
  container.innerHTML = html;
}

                
              function updateSenderProgressUI() {
              const container = document.getElementById('senderProgress');
              if (!fileTransferInProgress || totalPackets === 0) {
                container.innerHTML = "<p>No file being sent.</p>";
                return;
              }
              const now = Date.now();
              const elapsed = (now - sentFileStats.startTime) / 1000;
            
              // Calculate the percentage of packets acked and sent
              const ackedPercent = Math.floor((currentPacketIndex / totalPackets) * 100);
              const sentPercent = Math.floor((highestPacketSentSoFar / totalPackets) * 100);
              const orangePercent = sentPercent - ackedPercent; // sent but not yet acked
            
              let eta = "N/A";
              if (ackedPercent > 0) {
                let estimatedTotal = elapsed / (ackedPercent / 100);
                eta = (estimatedTotal - elapsed).toFixed(2) + " s";
              }
              const transferRate = elapsed > 0 ? sentFileStats.bytesSent / elapsed : 0;
              const retriesSoFar = totalRetries + currentRetries;
              const retryPercent = totalPackets ? Math.round((retriesSoFar / totalPackets) * 100) : 0;
            
              let statusText = "";
              if (ackTimer || (senderState === "Awaiting ACK" && (now - senderStateTimestamp < 1000))) {
                statusText = '<span style="color: orange; font-weight: bold;">Awaiting ACK</span>';
              } else {
                senderState = "Sending";
                statusText = '<span style="color: red; font-weight: bold;">Sending</span>';
              }
            
              container.innerHTML = `
                <h5>To ${sentFileStats.receiver} – ${sentFileStats.fileName} (ID: ${sentFileStats.fileId})<br>
                  (Acked: ${currentPacketIndex} / ${totalPackets}, Sent: ${highestPacketSentSoFar} / ${totalPackets})
                </h5>
                <p>Original Size: ${sentFileStats.originalSize} bytes; Compressed Size: ${sentFileStats.compressedSize} bytes</p>
                <div class="progress mb-2" style="height: 20px;">
                  <!-- Blue progress for acked packets -->
                  <div class="progress-bar bg-primary" role="progressbar" 
                       style="width: ${ackedPercent}%;" aria-valuenow="${ackedPercent}" 
                       aria-valuemin="0" aria-valuemax="100">
                       ${ackedPercent}%
                  </div>
                  <!-- Orange progress for packets sent but not yet acked -->
                  <div class="progress-bar bg-warning" role="progressbar" 
                       style="width: ${orangePercent}%;" aria-valuenow="${orangePercent}" 
                       aria-valuemin="0" aria-valuemax="100">
                       ${orangePercent > 0 ? orangePercent + '%' : ''}
                  </div>
                </div>
                <p>
                  ${statusText}<br>
                  Elapsed time: ${elapsed.toFixed(2)} s; ETA: ${eta} 
                  (${transferRate.toFixed(0)} bytes/sec); Retries: ${retriesSoFar} (${retryPercent}%)
                </p>
                <div style="margin-top: 0.5rem;">
                  <button class="btn btn-danger btn-sm" onclick="cancelSenderTransfer()">Cancel</button>
                </div>
              `;
              }
            
            
            function finalizeTransfer() {
              updateStatus("File transfer complete.");
              sentFileStats.endTime = Date.now();
              sentFileStats.totalTime = ((sentFileStats.endTime - sentFileStats.startTime) / 1000).toFixed(2);
              sentFileStats.totalRetries = totalRetries + currentRetries;
              sentFileStats.timestamp = sentFileStats.startTime;
              persistentSentFiles.push(sentFileStats);
              saveSentFilesToLocalStorage(persistentSentFiles);
              updateSentFilesUI();
            
              // Capture final file ID for the final handshake:
              finalFileId = sentFileStats.fileId; // new global variable on sender side
            
              fileTransferInProgress = false;
	      
              updateSenderProgressUI();
              for (let key in activeTransfers) {
                if (activeTransfers[key].completed) {
                  delete activeTransfers[key];
                }
              }
              updateReceiverProgressUI();
              document.getElementById('sendFileBtn').disabled = false;
            
              // Start the FIN-ACK wait loop with the captured finalFileId.
              startFinAckWaitLoop(finalFileId);
	      expectedFileId = null;
              
              // Note: Do NOT clear sentFileStats immediately; let the FIN-ACK loop complete.
            }
            
            
            
            
              function startTransfer(fileId) {
              waitingForFinAckMap[fileId] = true; // Set final ACK wait for this specific fileId
              console.log("Transfer started with fileId:", currentFileId);
              }
            
                /***********************
                 * Receiver ACK Function
                 ***********************/
function sendAckFromReceiver(sender, fileId, ackStr) {
  let localCallsign = document.getElementById('senderCallsign').value.trim();
  const info = fileId + ':' + "ACK" + ':' + ackStr;
  const encoder = new TextEncoder();
  const infoBytes = encoder.encode(info);
  const ax25Header = buildAX25Header(localCallsign, sender);
  const ackPacket = new Uint8Array(ax25Header.length + infoBytes.length);
  ackPacket.set(ax25Header, 0);
  ackPacket.set(infoBytes, ax25Header.length);
  const ackKissFrame = buildKissFrame(ackPacket);

  // Look up the active transfer for this file so we can track ACK time.
  const transferKey = sender + "_" + fileId;
  if (activeTransfers[transferKey]) {
    activeTransfers[transferKey].lastAckTime = Date.now(); // <-- Add this line
  }

  console.log("Receiver sending ACK:", ackStr);

  // Send via your chosen connection
  if (document.getElementById('connectionType').value === 'websockets') {
    if (socket) socket.emit('raw_kiss_frame', ackKissFrame);
  } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
    serialWriter.write(ackKissFrame).catch(err => console.error("Error writing ACK:", err));
  }
}

            
                
                /***********************
                 * Helper Functions: Range Compression/Expansion
                 ***********************/
                function compressRanges(arr) {
                  if (!arr.length) return "";
                  arr = arr.map(Number).sort((a, b) => a - b);
                  let ranges = [];
                  let start = arr[0], prev = arr[0];
                  for (let i = 1; i < arr.length; i++) {
                    if (arr[i] === prev + 1) {
                      prev = arr[i];
                    } else {
                      ranges.push(start === prev ? String(start) : start + "-" + prev);
                      start = arr[i];
                      prev = arr[i];
                    }
                  }
                  ranges.push(start === prev ? String(start) : start + "-" + prev);
                  return ranges.join(",");
                }
                
                function expandRanges(rangeStr) {
                  let result = [];
                  let parts = rangeStr.split(",");
                  parts.forEach(part => {
                    let trimmed = part.trim();
                    if (!trimmed) return;
                    if (trimmed.indexOf("-") !== -1) {
                      let [start, end] = trimmed.split("-").map(x => parseInt(x, 16));
                      if (!isNaN(start) && !isNaN(end)) {
                        if (start > end) { [start, end] = [end, start]; }
                        for (let i = start; i <= end; i++) result.push(i);
                      } else if (!isNaN(start)) {
                        result.push(start);
                      }
                    } else {
                      let num = parseInt(trimmed, 16);
                      if (!isNaN(num)) result.push(num);
                    }
                  });
                  return result;
                }
                
                // NEW: Minimal implementation of updateBurstSlider to update the burst slider and label.
                function updateBurstSlider(index) {
                  const slider = document.getElementById('burstSlider');
                  const label = document.getElementById('burstValue');
                  if (slider) {
                    slider.value = index;
                  }
                  if (label) {
                    label.textContent = dynamicBurstSizes[index];
                  }
                }
                
                /***********************
                 * Utility Functions
                 ***********************/
                function padCallsign(cs) {
                  return cs.toUpperCase().padEnd(9, ' ');
                }
                
    
                
                /***********************
                 * AX.25 Header Helpers
                 ***********************/
                function encodeAX25Address(callsign, isLast) {
                  let call = callsign.toUpperCase();
                  let ssid = 0;
                  if (call.includes('-')) {
                    const parts = call.split('-');
                    call = parts[0];
                    ssid = parseInt(parts[1], 10) || 0;
                  }
                  call = call.padEnd(6, ' ').slice(0, 6);
                  const addr = new Uint8Array(7);
                  for (let i = 0; i < 6; i++) {
                    addr[i] = call.charCodeAt(i) << 1;
                  }
                  addr[6] = ((ssid & 0x0F) << 1) | 0x60;
                  if (isLast) addr[6] |= 0x01;
                  return addr;
                }
                
            function decodeAX25Address(addr) {
              // Expects a Uint8Array of length 7.
              let cs = "";
              for (let i = 0; i < 6; i++) {
                cs += String.fromCharCode(addr[i] >> 1);
              }
              cs = cs.trim();
              let ssid = (addr[6] >> 1) & 0x0F;
              if (ssid > 0) {
                cs += "-" + ssid;
              }
              return cs;
            }
            
            
                function buildAX25Header(source, destination) {
                  const destAddr = encodeAX25Address(destination, false);
                  const srcAddr = encodeAX25Address(source, true);
                  const control = new Uint8Array([0x03]);
                  const pid = new Uint8Array([0xF0]);
                  const header = new Uint8Array(7 + 7 + 1 + 1);
                  header.set(destAddr, 0);
                  header.set(srcAddr, 7);
                  header.set(control, 14);
                  header.set(pid, 15);
                  return header;
                }
                
                /***********************
                 * Packet Building Functions
                 ***********************/
            function buildPacket(sender, receiver, seq, totalPackets, payloadChunk, fileId, burstTo) {
              let seqStr = seq.toString(16).padStart(4, '0');
              let burstToStr = burstTo.toString(16).padStart(4, '0');
              let infoStr = "";
              if (seq === 1) {
                let totalStr = (totalPackets - 1).toString(16).padStart(4, '0');
                // Header packets now include only the fileId and sequence fields.
                infoStr = fileId + ':' + "0001" + burstToStr + '/' + totalStr + ':';
              } else {
                infoStr = fileId + ':' + seqStr + burstToStr + ':';
              }
              const encoder = new TextEncoder();
              const infoBytes = encoder.encode(infoStr);
              const innerPayload = new Uint8Array(infoBytes.length + payloadChunk.length);
              innerPayload.set(infoBytes, 0);
              innerPayload.set(payloadChunk, infoBytes.length);
              const ax25Header = buildAX25Header(sender, receiver);
              const packetBytes = new Uint8Array(ax25Header.length + innerPayload.length);
              packetBytes.set(ax25Header, 0);
              packetBytes.set(innerPayload, ax25Header.length);
              return packetBytes;
            }
            
                
                /***********************
                 * Receiver ACK Functions
                 ***********************/
            function sendCumulativeAck(transfer, sender, forceSend = false) {
              if (transfer.finalHandshakeReceived) {
                console.log("Final handshake received; skipping cumulative ACK.");
                return;
              }
              // Determine the highest contiguous packet number starting from packet 1.
              let cumulative = 1;
              while (transfer.received[cumulative]) {
                cumulative++;
              }
              cumulative--;  // highest contiguous packet number
            
              // Build the cumulative ACK string.
              let ackStr = cumulative > 1 
                ? "0001-" + cumulative.toString(16).padStart(4, '0') 
                : "0001";
            
              console.log("Receiver: Cumulative ACK for file", transfer.header.fileId, ":", ackStr);
              // Always use the fileId stored in the transfer header.
              sendAckFromReceiver(sender, transfer.header.fileId, ackStr);
              transfer.lastAcked = cumulative;
            }
            
                
                /***********************
                 * ACK Processing Functions
                 ***********************/
            function processAckFrame(infoText) {
              if (infoText.indexOf(":ACK:") === -1) return null;
              let parts = infoText.split(":");
              // Expect at least three fields: [fileId, "ACK", ackValue, ...]
              if (parts.length < 3) return null;
              return { fileId: parts[0].trim(), ack: parts[2].trim() };
            }
            
            
                
            
              function processAck(ackContent) {
              // Ensure the current ack is for the correct fileId
              if (waitingForFinAckMap[sentFileStats.fileId] && ackContent !== "0001" && waitingForFinAck) {
                console.log(`Sender: Received cumulative ACK during final wait for file ${sentFileStats.fileId} (waitingForFinAck is ${waitingForFinAck}), re-sending final FIN-ACK.`);
                sendFinalFinAck(sentFileStats.fileId);  // Resend the FIN-ACK for the correct fileId
                return;
              }
            
              // Process header ACK handling
              if (ackContent === "0001") {
                if (!headerAckReceived) {
                  headerAckReceived = true;
                  let headerAckTime = Date.now() - headerSentTimestamp;
                  perPacketTimeout = headerAckTime / 2;
                  console.log(`Processed header ACK: 0001; header ack time: ${headerAckTime}ms, setting perPacketTimeout to ${perPacketTimeout}ms`);
                  currentPacketIndex = 1;
                  if (headerAckTimer) {
		    console.log("Clearing headerAckTimer");
                    clearTimeout(headerAckTimer);
                    headerAckTimer = null;
                  }
                  if (!burstInProgress) {
                    sendBurstPackets();
                  }
                } else {
                  console.log("Duplicate header ACK received; resending next set of packets.");
                  sendBurstPackets();
                }
                return;
              }
            
              // Handle range ACKs (ackContent with '-' or ',')
              if (ackContent.indexOf('-') !== -1 || ackContent.indexOf(',') !== -1) {
                processRangeAck(ackContent);
                return;
              }
            
              // Handle duplicate ACKs
              if (ackContent === lastRangeAck) {
                duplicateAckCount++;
                console.log(`Received duplicate ACK (${duplicateAckCount}):`, ackContent);
                sendBurstPackets();
                if (duplicateAckCount >= 3) {
                  console.log("Three duplicate ACKs received; resending missing packets:", missingPackets);
                  missingPackets.forEach(seq => { 
  			sendPacket(seq, endSeq); 
			  totalRetries++; 
		  });
                  duplicateAckCount = 0;
                }
                return;
              } else {
                duplicateAckCount = 0;
                lastRangeAck = ackContent;
              }
            
              // Update currentPacketIndex based on the received ack number.
              let ackNum = parseInt(ackContent, 16);
              if (!isNaN(ackNum) && ackNum > currentPacketIndex) {
                currentPacketIndex = ackNum;
                console.log("Sender: Cumulative ACK updated currentPacketIndex to", currentPacketIndex);
                updateSenderProgressUI();
              }
            
              // Handle final packet receipt (check for completion)
              if (currentPacketIndex >= totalPackets &&
                  highestPacketSentSoFar >= totalPackets &&
                  missingPackets.length === 0) {
                updateStatus("Final ACK received. Sending FIN-ACK immediately.");
                sendFinalFinAck(currentFileId);
                finalizeTransfer();
                return;
              }
            
              // Send next burst if not in final wait and burst is not in progress.
              if (!burstInProgress && currentPacketIndex < totalPackets) {
                sendBurstPackets();
              }
              }
            
            
                

        
     
 function processRangeAck(ackContent) {
  let receivedList = expandRanges(ackContent).sort((a, b) => a - b);

  let newIndex = currentPacketIndex;
  let expected = currentPacketIndex + 1;
  while (receivedList.includes(expected)) {
    newIndex = expected;
    expected++;
  }

  console.log("processRangeAck: Received ACK range", ackContent, "-> newIndex =", newIndex);

  if (newIndex <= currentPacketIndex) {
    duplicateAckCount++;
    console.log("Received duplicate range ACK (" + duplicateAckCount + "):", ackContent);
    sendBurstPackets();
    return;
  }

  duplicateAckCount = 0;
  lastRangeAck = ackContent;
  currentPacketIndex = newIndex;
  missingPackets = [];

  console.log("Sender: Cumulative ACK received. Updated highest contiguous ACK to", newIndex);

  if (ackTimer) {
    clearTimeout(ackTimer);
    console.log(`Sender: Clearing ackTimer, received valid ACK range = ${ackContent}`);
    ackTimer = null;
  }
  
  let burstAckTime = Date.now() - burstStartTimestamp;
  console.log("Burst ACK time:", burstAckTime, "ms for", lastBurstSentCount, "packets");
  if (lastBurstSentCount > 0) {
    perPacketTimeout = burstAckTime / lastBurstSentCount;
    console.log("Updated perPacketTimeout to", perPacketTimeout, "ms based on burst ACK");
  }
  dataRetryCount = 0;

  burstInProgress = false;
  updateSenderProgressUI();

  if (currentPacketIndex >= totalPackets &&
      highestPacketSentSoFar >= totalPackets &&
      missingPackets.length === 0) {
    updateStatus("Final ACK received.");
    finalizeTransfer();
    return;
  }

  if (burstSize !== 0 && currentPacketIndex < totalPackets) {
    sendBurstPackets();
  }

  if (burstSize === 0) { 
    if (missingPackets.length === 0) {
      consecutiveSuccessCount++;
      console.log("Consecutive success count:", consecutiveSuccessCount);
      if (consecutiveSuccessCount >= 2) {
        if (currentDynamicBurstIndex < dynamicBurstSizes.length - 1) {
          currentDynamicBurstIndex++;
          currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
          console.log("Dynamic burst increased to", currentBurstSizeDynamic);
          updateBurstSlider(currentDynamicBurstIndex);
        } else {
          console.log("Dynamic burst is already at maximum index.");
        }
        consecutiveSuccessCount = 0;
      }
    } else {
      if (currentDynamicBurstIndex > 0) {
        currentDynamicBurstIndex--;
        currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
        console.log("Dynamic burst decreased to", currentBurstSizeDynamic);
        updateBurstSlider(currentDynamicBurstIndex);
      }
      consecutiveSuccessCount = 0;
    }
    sendBurstPackets();
  }
}
       

                
                /***********************
                 * FIN-ACK Functions (Sender & Receiver) – UPDATED WITH RETRY LOOP
                 ***********************/
            function sendFinalFinAck(fileId) {
      if (waitingForFinAckMap[fileId]) {
        // Construct the info payload like a normal ACK.
        const finalInfo = fileId + ':' + "ACK" + ':' + "FIN-ACK";
        const encoder = new TextEncoder();
        const infoBytes = encoder.encode(finalInfo);
        const ax25Header = buildAX25Header(sender, receiver);
        const packetBytes = new Uint8Array(ax25Header.length + infoBytes.length);
        packetBytes.set(ax25Header, 0);
        packetBytes.set(infoBytes, ax25Header.length);
        const finalFrame = buildKissFrame(packetBytes);
        console.log(`Sender: Sending FIN-ACK for file ${fileId}.`);
        if (document.getElementById('connectionType').value === 'websockets') {
          if (socket) socket.emit('raw_kiss_frame', finalFrame);
        } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
          serialWriter.write(finalFrame).catch(err => console.error("Error sending FIN-ACK:", err));
        }
      } else {
        console.log(`Sender: No such fileId waiting for FIN-ACK ${fileId}.`);
      }
    }
    
            
            
                
            function startFinAckWaitLoop(fileId) {
              // Get base timeout from UI and compute finalAckTimeout
              let baseTimeout = parseFloat(document.getElementById('timeoutSeconds').value) * 1000;
              finalAckTimeout = baseTimeout ? baseTimeout * 1.5 : 7500;
            
              waitingForFinAck = true;
              console.log("Sender: Sending FIN-ACK and starting final wait period of " + finalAckTimeout + " ms. File ID:", fileId);
              sendFinalFinAck(fileId);
            
              finalAckRetryTimer = setTimeout(() => {
                console.log("Sender: Final wait period expired; ending FIN-ACK wait loop.");
                waitingForFinAck = false;
                // Now that the FIN-ACK loop is done, you can clear sentFileStats if desired:
                sentFileStats = null;
              }, finalAckTimeout);
            }
            
            
            function scheduleNextFinAckAttempt(fileId) {
              if (!waitingForFinAck) return;
              if (currentFinAckRetryCount >= maxFinalAckRetries) {
                console.log("Sender: Gave up waiting for final FIN-ACK after", currentFinAckRetryCount, "retries.");
                waitingForFinAck = false;
                return;
              }
              currentFinAckRetryCount++;
              console.log(`Sender: Attempt #${currentFinAckRetryCount}, waiting for FIN-ACK for ${finalAckTimeout} ms... File ID: ${fileId}`);
              finalAckRetryTimer = setTimeout(() => {
                if (!waitingForFinAck) return;
                console.log("Sender: FIN-ACK timeout reached, resending FIN-ACK...");
                sendFinalFinAck(fileId);
                scheduleNextFinAckAttempt(fileId);
              }, finalAckTimeout);
            }
            
                
                /***********************
                 * Process Raw Packet (Updated FIN-ACK handling)
                 ***********************/
            function processRawPacket(packet) {
              console.log("Processing raw packet:", packet);
              let packetBytes;
              if (typeof packet === 'string') {
                packetBytes = new TextEncoder().encode(packet);
              } else if (packet instanceof ArrayBuffer) {
                packetBytes = new Uint8Array(packet);
              } else if (packet instanceof Uint8Array) {
                packetBytes = packet;
              } else {
                console.log("Unrecognized packet type; ignoring.");
                return;
              }
            
              if (packetBytes[0] !== 0xC0 || packetBytes[packetBytes.length - 1] !== 0xC0) {
                console.error("Invalid KISS frame: missing framing bytes.");
                return;
              }
            
            const ax25Frame = packetBytes.slice(2, packetBytes.length - 1);
            if (ax25Frame.length < 16) {
              return;
            }
            const header = ax25Frame.slice(0, 16); // Extract the first 16 bytes as the AX.25 header
            const infoField = ax25Frame.slice(16);
            let infoText = new TextDecoder().decode(infoField);
        
            // --- New: Process RSP packets (responses to CMD packets) ---
if (infoText.split(":")[1] && infoText.split(":")[1].toUpperCase() === "RSP") {
  const rsp = parseRspPacket(infoField);
  if (rsp.ok && pendingCmdResponses[rsp.cmdID]) {
    if (rsp.status === 0) {
      console.log("Received CMD RSP with status 0:", rsp.message);
      // Check if the web view modal is open
      const webViewModal = document.getElementById('webViewModal');
      if (webViewModal && webViewModal.classList.contains('show')) {
        showWebViewErrorOverlay("CMD failed: " + rsp.message);
      }
      // Optionally, update the global status as well.
      updateStatus("CMD failed: " + rsp.message);
    }
    pendingCmdResponses[rsp.cmdID].resolve(rsp);
    delete pendingCmdResponses[rsp.cmdID];
  } else {
    console.warn("Received RSP for unknown CMD ID or with error:", rsp.error);
  }
  return;
}


            
            if (infoText.indexOf(":ACK:FIN-ACK") !== -1) {
              let parts = infoText.split(":"); // Expected format: fileId, "ACK", "FIN-ACK"
              if (parts.length < 3) return;
              let fileIdFromAck = parts[0].trim();
              let localCallsign = document.getElementById('senderCallsign').value.trim();
              // Now look up the active transfer using fileIdFromAck
              for (let key in activeTransfers) {
                let transfer = activeTransfers[key];
                if (transfer.header && transfer.header.fileId === fileIdFromAck) {
                  if (!transfer.waitingForFinAck) {
                    console.log("Receiver: Received FIN-ACK but not waiting for it. Ignoring.");
                    return;
                  }
                  console.log("Receiver: FIN-ACK received for file", fileIdFromAck, "for transfer", key);
                  transfer.finalHandshakeReceived = true;
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                  return;
                }
              }
              console.log("Receiver: FIN-ACK received, but no active transfer matches fileId", fileIdFromAck);
              return;
            }
            
            
            
              // *** NEW: Check for ACK frames before processing as data/header packet ***
            if (infoText.indexOf(":ACK:") !== -1) {
              let ackData = processAckFrame(infoText);
              if (!ackData) return;
              
              // Check against active transfer state if available...
              if (sentFileStats) {
                if (ackData.fileId !== sentFileStats.fileId) {
                  console.log("Ignoring ACK for file", ackData.fileId, "while current file is", sentFileStats.fileId);
                  return;
                }
              } 
              // If no active transfer, check finalFileId:
              else if (finalFileId) {
                if (ackData.fileId !== finalFileId) {
                  console.log("Ignoring ACK for file", ackData.fileId, "while final file is", finalFileId);
                  return;
                }
              } 
              // If neither, ignore.
              else {
                console.log("No active transfer or final file; ignoring ACK.");
                return;
              }
              
              console.log("Sender received ACK:", ackData.ack, "for file", ackData.fileId);
              processAck(ackData.ack);
              burstInProgress = false;
              return;
            }
            
              // *** End of ACK check ***
            
            
            // Now decode sender/receiver from the header:
            const senderStr = decodeAX25Address(header.slice(7, 14));
            const receiverStr = decodeAX25Address(header.slice(0, 7));
    
    	if (document.getElementById('restrictCallsign').checked) {
    	  const allowedCallsign = document.getElementById('receiverCallsign').value.trim().toUpperCase();
    	  if (senderStr !== allowedCallsign) {
    	    console.log(`Ignoring packet from ${senderStr} as it does not match remote callsign ${allowedCallsign}.`);
    	    return;
    	  }
    	}
           
            // Then parse the info field which now has the new format:
            // Expected formats:
            //   - ACK packets: fileId + ':' + "ACK" + ':' + ackValue + ':'
            //   - Data packets (header, seq==1): fileId + ':' + "0001XXXX/YYYY" + ':'
            //   - Data packets (seq > 1): fileId + ':' + seq(4 hex digits) + burstTo(4 hex digits) + ':'
            let parts = infoText.split(":");
            if (parts.length < 2) {
              console.log("Packet format invalid: not enough fields");
              return;
            }
            let packetFileId = parts[0].trim();
            let seqBurst = parts[1].trim();
            
            let seq, burstTo;
            if (seqBurst.indexOf("/") !== -1) {
              // Header packet (seq==1); expect format like "0001XXXX/YYYY"
              seq = 1;
              if (seqBurst.length < 8) {
                console.log("Header packet format invalid: insufficient length");
                return;
              }
              burstTo = parseInt(seqBurst.substring(4, 8), 16);
            } else {
              // Data packet; expect exactly 8 hex digits
              if (seqBurst.length !== 8) {
                console.log("Data packet format invalid: sequence field length is not 8");
                return;
              }
              seq = parseInt(seqBurst.substring(0, 4), 16);
              burstTo = parseInt(seqBurst.substring(4, 8), 16);
            }
            
            
              // Ignore packets not addressed to me
              if (receiverStr !== document.getElementById('senderCallsign').value.trim()) {
                console.log("Ignoring packet not intended for me (packet receiver:",
                  receiverStr, ", local:", document.getElementById('senderCallsign').value.trim(), ")");
                return;
              }
            
              // Calculate payload offset based on sequence number
              let offset = (seq === 1) ? 17 : 12;
              let payloadChunk = unescapeKissData(infoField.slice(offset));
            
              let transferKeyFinal = senderStr + "_" + packetFileId;
            
              // --- Header Branch: When seq === 1, start a new transfer ---
             
            // --- Header Branch: When seq === 1, start a new transfer ---
            if (seq === 1 && !activeTransfers[transferKeyFinal]) {
    
      let headerFileId = packetFileId; // obtained from the packet header
      
      // If file server mode is enabled and we have an expected fileId from GET,
      // ensure that they match.
      if (document.getElementById('isFileServer').checked && expectedFileId) {
        if (headerFileId !== expectedFileId) {
          console.error("Incoming file ID does not match expected cmdID:", headerFileId, expectedFileId);
          // Optionally, ignore this transfer:
          return;
        }
	expectedFileId = null;
      }
    
    
              console.log("Starting new transfer from sender", senderStr, "with file ID", packetFileId);
              // Decode the header payload to get the transfer parameters
              let headerPayloadText = new TextDecoder().decode(payloadChunk);
              let parts = headerPayloadText.split("|");
              // Calculate header timeout based on the first part (timeoutSeconds)
              const headerTimeout = (parseFloat(parts[0]) * 1000) + 1500;
              
              activeTransfers[transferKeyFinal] = {
                totalChunks: parseInt(parts[9], 10),
                received: {},
                startTime: Date.now(),
                duplicateCount: 0,
                lastUpdate: Date.now(),
                ackTimer: null,
                lastPacketTime: Date.now(),
                ackDelay: headerTimeout, // calculated from header data
                currentBurstBoundary: 0,
                burstStartTime: Date.now(),
                maxAckRetries: parseInt(parts[1], 10) || 5,
                ackRetryCount: 0,
                ackRetryActive: true
              };
            
              activeTransfers[transferKeyFinal].received[1] = true;
            
              activeTransfers[transferKeyFinal].header = {
                fileName: parts[2],
                originalSize: parseInt(parts[3], 10),
                compressedSize: parseInt(parts[4], 10),
                md5: parts[5],
                fileId: packetFileId, // store the file ID from the packet
                encodingMethod: parseInt(parts[7], 10),
                compression: (parts[8] === "1"),
                expectedTotal: parseInt(parts[9], 10)
              };
            
              console.log("Received header from sender", senderStr, "for file ID", packetFileId, activeTransfers[transferKeyFinal].header);
              sendAckFromReceiver(senderStr, packetFileId, "0001");
              return;
            }
            
            
              let transfer = activeTransfers[transferKeyFinal];
              if (!transfer) {
              console.log("No active transfer record for", transferKeyFinal, "- transfer already finalized.");
              return;
              }
            
              if (!transfer.currentBurstTo || burstTo > transfer.currentBurstTo) {
                transfer.currentBurstTo = burstTo;
              }
            
              let isDuplicate = !!transfer.received[seq];
              if (!isDuplicate) {
                transfer.received[seq] = payloadChunk;
              } else {
                transfer.duplicateCount++;
                console.log("Duplicate packet", seq, "received from", transferKeyFinal);
              }
            
              if (!transfer.rawBytesReceived) transfer.rawBytesReceived = 0;
              transfer.rawBytesReceived += infoField.length;
              transfer.lastUpdate = Date.now();
              console.log("Stored packet", seq, "from", transferKeyFinal, `(${Object.keys(transfer.received).length} / ${transfer.totalChunks})`);
              updateReceiverProgressUI();
            
              if (seq === 1) return;
            
              let contiguous = 2;
              while (transfer.received[contiguous]) contiguous++;
              transfer.lastAcked = contiguous - 1;
            
              // --- ACK sending branch: Send ACK and start exponential retry ---
              if (!isDuplicate && !transfer.completed) {
                transfer.lastPacketTime = Date.now();
                if (transfer.ackTimer) {
                  clearTimeout(transfer.ackTimer);
                  transfer.ackTimer = null;
                }
                // Reset the ACK retry counter for this ACK cycle
                transfer.ackRetryCount = 0;
                
                if ((contiguous - 1) >= burstTo) {
                  console.log("Receiver: Reached highest burst seq (" + burstTo + "), ACKing immediately.");
                  sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
            
              (function ackRetry() {
              // Immediately exit if the final handshake is complete.
              if (transfer.finalHandshakeReceived) {
                console.log("Receiver: Final handshake done, stopping ACK retries.");
                return;
              }
              if (transfer.ackRetryCount >= transfer.maxAckRetries) {
                console.log("Receiver: ACK retry max reached (" + transfer.maxAckRetries + "). Aborting transfer.");
                // Mark the transfer as aborted or remove it from activeTransfers.
                delete activeTransfers[senderStr + "_" + transfer.header.fileId];
                updateReceiverProgressUI();
                updateStatus("Receiver: Transfer for file " + transfer.header.fileId + " aborted due to ACK timeout.");
                transfer.ackTimer = null;
                return;
              }
              transfer.ackRetryCount++;
              let nextDelay = transfer.ackDelay * Math.pow(1.5, transfer.ackRetryCount);
              transfer.ackTimer = setTimeout(() => {
                if (transfer.finalHandshakeReceived) {
                  console.log("Receiver: Final handshake received; not resending cumulative ACK.");
                  return;
                }
                console.log("Receiver: ACK retry attempt #" + transfer.ackRetryCount + ", resending cumulative ACK.");
                sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
                ackRetry();
              }, nextDelay);
              })();
            
            
                } else {
                  transfer.ackTimer = setTimeout(() => {
                    console.log("Receiver: Idle period reached, sending partial/cumulative ACK.");
                    sendCumulativeAck(transfer, senderStr, transfer.header.fileId, true);
                    transfer.ackTimer = null;
                  }, transfer.ackDelay);
                }
              }
            
              let allPacketsReceived = transfer.totalChunks && Object.keys(transfer.received).length === transfer.totalChunks;
            
            if (!transfer.completed && allPacketsReceived) {
              if (transfer.downloadTriggered) return;
              transfer.downloadTriggered = true;
            
              if (transfer.header && persistentReceivedFiles.some(f => f.fileId === transfer.header.fileId && f.sender === senderStr)) {
                console.log("File already processed, skipping reassembly and download.");
                return;
              }
            
                console.log("All packets received for", transferKeyFinal, "- reassembling file...");
                if (!transfer.header) {
                  console.error("Missing header for", transferKeyFinal);
                  return;
                }
            
                let dataChunks = [];
                for (let i = 2; i <= transfer.totalChunks; i++) {
                  if (!transfer.received[i]) {
                    console.error("Missing packet", i, "for", transferKeyFinal);
                    return;
                  }
                  let chunk = transfer.received[i];
                  if (transfer.header.encodingMethod === 1) {
                    let base64Str = new TextDecoder().decode(chunk);
                    let binaryStr = atob(base64Str);
                    let decodedChunk = new Uint8Array(binaryStr.length);
                    for (let j = 0; j < binaryStr.length; j++) {
                      decodedChunk[j] = binaryStr.charCodeAt(j);
                    }
                    dataChunks.push(decodedChunk);
                  } else {
                    dataChunks.push(chunk);
                  }
                }
                let totalLength = dataChunks.reduce((acc, c) => acc + c.length, 0);
                let fullCompressed = new Uint8Array(totalLength);
                let offsetVal = 0;
                dataChunks.forEach(chunk => {
                  fullCompressed.set(chunk, offsetVal);
                  offsetVal += chunk.length;
                });
                console.log("Reassembled compressed file length:", fullCompressed.length);
            
                let decompressed;
                if (transfer.header.compression) {
                  try {
                    decompressed = pako.inflate(fullCompressed);
                  } catch (err) {
                    console.error("Error decompressing file for", transferKeyFinal, ":", err);
                    return;
                  }
                } else {
                  decompressed = fullCompressed;
                }
                if (!decompressed) {
                  console.error("Decompression failed: decompressed data is undefined");
                  return;
                }
                console.log("Decompressed file length:", decompressed.length);
            
                const blob = new Blob([decompressed]);
        
        if (transfer.header.fileName.trim() === "LIST.txt") {
          // Process the CSV asynchronously.
          const readerText = new FileReader();
          readerText.onload = function(e) {
            const csvText = e.target.result;
            processListFile(csvText);
            // Optionally, update state to indicate that LIST.txt has been handled.
          };
          readerText.onerror = function(e) {
            console.error("Error reading LIST file:", e);
          };
          readerText.readAsText(blob);
        
          // Instead of returning immediately, allow the FIN-ACK process to complete.
          // You might set a flag so that the normal download isn't triggered later.
          transfer.isListFile = true;
          console.log("Processing LIST.txt file via CSV parser, but continuing with FIN-ACK.");
          // Do not return here—continue so that the final ack cycle still runs.
        } else if (transfer.header.fileName.trim() === "index.html") {
  // Process index.html without prompting a download.
  const readerText = new FileReader();
readerText.onload = function(e) {
  cachedIndexHTML = e.target.result; // Cache the HTML content.
  console.log("index.html cached for web view.");
  // If the webViewModal is already open, load the HTML with its assets.
  const modalInstance = bootstrap.Modal.getInstance(document.getElementById('webViewModal'));
  if (modalInstance) {
    loadIndexWithAssetsSequentially(cachedIndexHTML);
  }
};

  readerText.onerror = function(e) {
    console.error("Error reading index.html:", e);
  };
  readerText.readAsText(blob);
  transfer.isIndexFile = true;
  console.log("Processing index.html file; caching content for web view.");
  // Continue with any FIN-ACK processes as needed.
}

        
                const elapsedTotal = Date.now() - transfer.startTime;
                const dupCount = transfer.duplicateCount;
                const computedMd5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(decompressed)).toString();
                const checksumMatch = (computedMd5 === transfer.header.md5);
            
                const fileObj = {
                  sender: senderStr,
                  fileName: transfer.header.fileName,
                  originalSize: transfer.header.originalSize,
                  compressedSize: transfer.header.compressedSize,
                  size: blob.size,
                  elapsed: elapsedTotal,
                  duplicates: dupCount,
                  totalPackets: transfer.totalChunks,
                  timestamp: Date.now(),
                  checksumMatch: checksumMatch,
                  bytesReceived: transfer.rawBytesReceived || 0,
                  fileId: transfer.header.fileId
                };
            
                const reader = new FileReader();
                reader.onload = function(e) {
                  fileObj.dataUrl = e.target.result;
                  let existingIndex = persistentReceivedFiles.findIndex(
                    f => f.fileId === fileObj.fileId && f.sender === fileObj.sender
                  );
                  if (existingIndex !== -1) {
                    persistentReceivedFiles[existingIndex] = fileObj;
                  } else {
                    persistentReceivedFiles.push(fileObj);
                    existingIndex = persistentReceivedFiles.length - 1;
                  }
                  saveReceivedFilesToLocalStorage(persistentReceivedFiles);
                  updateReceivedFilesUI();
            
                  if (checksumMatch) {
  if (!transfer.isListFile) {
    if (autoSaveFilesEnabled) {
      downloadReceivedFile(fileObj.fileId);
    } else {
      console.log("Auto-save disabled; not automatically downloading the file.");
    }
    // For text files, you may still wish to open them in the modal:
    if (fileObj.fileName.toLowerCase().endsWith('.txt')) {
      viewReceivedFile(fileObj.fileId);
    }
  } else {
    console.log("LIST.txt processed; skipping normal download.");
  }
} else {
  console.error("Checksum does not match; automatic download aborted.");
  updateStatus("Received file failed checksum verification.");
}

                };
                reader.onerror = function(e) {
                  console.error("Error converting Blob:", e);
                };
                reader.readAsDataURL(blob);
                console.log("Receiver: Entire file complete.");
            
            console.log("Receiver: Entire file complete. Sending final cumulative ACK and waiting for FIN-ACK.");
              transfer.waitingForFinAck = true;  // Mark that we are waiting for the sender's FIN-ACK. 
              // Do not mark transfer.completed or remove it yet.
              return;
              }
              }
            
                
                /***********************
                 * Sender ACK Handling & Burst Sending
                 ***********************/

 function sendBurstPackets() {
  if (!fileTransferInProgress) return;

  // If there are missing packets, resend them first.
  if (missingPackets.length > 0) {
    console.log("Sender: Resending missing packets:", missingPackets);

    missingPackets.forEach(seq => {
      sendPacket(seq);
      totalRetries++;
    });

    // Calculate how long to wait before expecting an ACK.
    const userTimeoutMs = (parseFloat(document.getElementById('timeoutSeconds')?.value) * 1000) || 5000;
    const effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
    const burstTimeout = (effectiveBurst * perPacketTimeout) + userTimeoutMs;

    // Increment burst ID for this new missing-packets burst.
    currentBurstId++;
    const thisBurstId = currentBurstId;

    console.log(`Sender: Scheduling ackTimer for missing packets. burstTimeout=${burstTimeout}ms, burstId=${thisBurstId}`);
    ackTimer = setTimeout(() => {
      // Check if this timer is still valid.
      if (thisBurstId !== currentBurstId) return; // Outdated timer; do nothing.

      console.log(`[AckTimer] Fired after missing-packets burstTimeout=${burstTimeout}ms`);
      dataRetryCount++;
      console.log(`Sender: dataRetryCount incremented to ${dataRetryCount}`);

      if (dataRetryCount > getMaxRetries()) {
        updateStatus("No ACK received after max retries (missing packets). Aborting transfer.");
        cancelSenderTransfer();
        return;
      }

      console.log(`Sender: No ACK at all for these packets; marking them missing and retrying.`);
      missingPackets = [];
      for (let seq = currentPacketIndex + 1; seq <= currentPacketIndex + effectiveBurst; seq++) {
        missingPackets.push(seq);
      }
      burstInProgress = false;
      sendBurstPackets();

    }, burstTimeout);

    return;
  }

  if (currentPacketIndex >= totalPackets) {
    finalizeTransfer();
    return;
  }

  // Prevent re-entrancy if already in a burst.
  if (burstInProgress) {
    console.log("Sender: Attempted to burst but burstInProgress is true; skipping.");
    return;
  }
  burstInProgress = true;

  // Calculate burst window.
  const effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
  const startSeq = currentPacketIndex + 1;
  const endSeq = Math.min(totalPackets, currentPacketIndex + effectiveBurst);
  lastBurstSentCount = endSeq - startSeq + 1;
  burstStartTimestamp = Date.now();

  // Increment burst ID for the new burst and capture it.
  currentBurstId++;
  const thisBurstId = currentBurstId;

  console.log(`Sender: Sending burst from seq=${startSeq} to seq=${endSeq} (count=${lastBurstSentCount}), burstId=${thisBurstId}`);
  for (let seq = startSeq; seq <= endSeq; seq++) {
    sendPacket(seq);
  }

  const userTimeoutMs = (parseFloat(document.getElementById('timeoutSeconds')?.value) * 1000) || 5000;
  const burstTimeout = (lastBurstSentCount * perPacketTimeout) + userTimeoutMs;
  console.log(`Sender: Scheduling ackTimer with burstTimeout=${burstTimeout}ms, burstId=${thisBurstId}`);

  ackTimer = setTimeout(() => {
    // Before processing, check if this timer is for the current burst.
    if (thisBurstId !== currentBurstId) return; // This timer is outdated, so skip.
    
    try {
      console.log(`[AckTimer] Fired after burstTimeout=${burstTimeout}ms (seqs ${startSeq}..${endSeq})`);
      dataRetryCount++;
      console.log(`Sender: dataRetryCount incremented to ${dataRetryCount}`);

      if (dataRetryCount > getMaxRetries()) {
        updateStatus("No ACK received for this burst after max retries. Aborting transfer.");
        cancelSenderTransfer();
        return;
      }

      console.log(`Sender: No ACK at all for these packets; marking them missing and retrying.`);
      missingPackets = [];
      for (let seq = startSeq; seq <= endSeq; seq++) {
        missingPackets.push(seq);
      }
      burstInProgress = false;
      sendBurstPackets();

    } catch (err) {
      console.error("[AckTimer] Uncaught error in burst callback:", err);
    }
  }, burstTimeout);
}


                
function sendPacket(seq, overrideBurstTo) {
  if (seq > highestPacketSentSoFar) {
    highestPacketSentSoFar = seq; 
  }
  let payloadChunk = fileDataChunks[seq - 1];
  let effectiveBurst = (burstSize === 0 ? currentBurstSizeDynamic : burstSize);
  // Use overrideBurstTo if provided; otherwise, calculate it normally.
  let currentBurstTo = (overrideBurstTo !== undefined)
                         ? overrideBurstTo
                         : Math.min(totalPackets, currentPacketIndex + effectiveBurst);
  if (seq === 1) {
    currentBurstTo = 1;
  }
  let packet = buildPacket(sender, receiver, seq, totalPackets, payloadChunk, fileId, currentBurstTo);
  sentFileStats.bytesSent = (sentFileStats.bytesSent || 0) + packet.length;
  console.log(`Sending packet ${seq} of ${totalPackets}`);
  const kissFrame = buildKissFrame(packet);

  if (document.getElementById('connectionType').value === 'websockets') {
    if (socket) socket.emit('raw_kiss_frame', kissFrame);
  } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
    serialWriter.write(kissFrame).catch(err => console.error("Error sending packet:", err));
  }
}

                
                /***********************
                 * KISS Framing Functions
                 ***********************/
                function escapeKissData(data) {
                  let output = [];
                  for (let i = 0; i < data.length; i++) {
                    let byte = data[i];
                    if (byte === 0xC0) output.push(0xDB, 0xDC);
                    else if (byte === 0xDB) output.push(0xDB, 0xDD);
                    else output.push(byte);
                  }
                  return new Uint8Array(output);
                }
                
                function unescapeKissData(data) {
                  let output = [];
                  for (let i = 0; i < data.length; i++) {
                    if (data[i] === 0xDB && i + 1 < data.length) {
                      if (data[i+1] === 0xDC) { output.push(0xC0); i++; continue; }
                      else if (data[i+1] === 0xDD) { output.push(0xDB); i++; continue; }
                    }
                    output.push(data[i]);
                  }
                  return new Uint8Array(output);
                }
                
                function buildKissFrame(aprsPacket) {
                  const escapedPacket = escapeKissData(aprsPacket);
                  const KISS_FLAG = 0xC0, KISS_CMD_DATA = 0x00;
                  let frame = new Uint8Array(1 + 1 + escapedPacket.length + 1);
                  frame[0] = KISS_FLAG;
                  frame[1] = KISS_CMD_DATA;
                  frame.set(escapedPacket, 2);
                  frame[frame.length - 1] = KISS_FLAG;
                  return frame;
                }
                
                function concatUint8Arrays(a, b) {
                  let c = new Uint8Array(a.length + b.length);
                  c.set(a, 0);
                  c.set(b, a.length);
                  return c;
                }
                
                window.processRawPacket = processRawPacket;
                
                function updateConnectionIndicator() {
                  const dot = document.getElementById('connectionStatusDot');
                  if (document.getElementById('connectionType').value === 'websockets')
                    dot.style.backgroundColor = (socket && socket.connected) ? 'green' : 'red';
                  else
                    dot.style.backgroundColor = serialConnected ? 'green' : 'red';
                  updateSendButtonStatus();
    	      updateListFilesButtonStatus();
                }
                
                function updateSendButtonStatus() {
                  const sendBtn = document.getElementById('sendFileBtn');
                  sendBtn.disabled = (document.getElementById('connectionType').value === 'websockets')
                                     ? !(socket && socket.connected) : !serialConnected;
                }
                
              function initializeWebSocket() {
              if (socket) return;
              socket = io('/');
              // Removed logging from onAny:
              socket.onAny((event, ...args) => { /* No logging here */ });
            
              socket.on('connect', () => { 
                console.log("Websocket connected, id:", socket.id);
                updateConnectionIndicator();
              });
            
              socket.on('disconnect', () => { 
                console.log("Websocket disconnected.");
                updateConnectionIndicator();
              });
            
              socket.on('connect_error', (err) => { 
                // Removed logging for connect_error
                updateConnectionIndicator();
              });
            
              socket.on('raw_kiss_frame', (packet) => { 
                // Removed logging for raw_kiss_frame
                processRawPacket(packet);
              });
            
              updateConnectionIndicator();
              }
            
                
                async function readSerial() {
      // Continue reading as long as the serial port is open and has a readable stream.
      while (serialPort && serialPort.readable && !stopReading) {
        // Use the global serialReader variable.
        serialReader = serialPort.readable.getReader();
        try {
          while (true) {
            // Check the flag inside the inner loop, too.
            if (stopReading) break;
    
            const { value, done } = await serialReader.read();
            if (done) break;
            if (value) {
              // Append new data to the buffer.
              kissBuffer = concatUint8Arrays(kissBuffer, value);
              // Process complete frames from the buffer.
              let startIndex = kissBuffer.indexOf(0xC0);
              while (startIndex !== -1) {
                let endIndex = kissBuffer.indexOf(0xC0, startIndex + 1);
                if (endIndex === -1) break;
                const frame = kissBuffer.slice(startIndex, endIndex + 1);
                processRawPacket(frame);
                kissBuffer = kissBuffer.slice(endIndex + 1);
                startIndex = kissBuffer.indexOf(0xC0);
              }
            }
          }
        } catch (error) {
          console.error("Error reading serial port:", error);
        } finally {
      if (serialReader && typeof serialReader.releaseLock === 'function') {
        serialReader.releaseLock();
        serialReader = null;
      }
    }
      }
    }
                
                document.addEventListener("DOMContentLoaded", function() {

		  const params = new URLSearchParams(window.location.search);
		  const connectionParam = params.get('connection');

		  if (connectionParam === 'serial' || connectionParam === 'websockets') {
		    const connectionSelect = document.getElementById('connectionType');
		    connectionSelect.value = connectionParam;
		  }

                  const storedSenderCallsign = localStorage.getItem('senderCallsign');
                  if (storedSenderCallsign) {
                    document.getElementById('senderCallsign').value = storedSenderCallsign;
                  }
                
                  const storedReceiverCallsign = localStorage.getItem('receiverCallsign');
                  if (storedReceiverCallsign) {
                    document.getElementById('receiverCallsign').value = storedReceiverCallsign;
                  }
                
                  // 3) Set up event listeners to persist changes back to localStorage
                  document.getElementById('senderCallsign').addEventListener('input', () => {
                    localStorage.setItem('senderCallsign', document.getElementById('senderCallsign').value);
                  });
                
                  document.getElementById('receiverCallsign').addEventListener('input', () => {
                    localStorage.setItem('receiverCallsign', document.getElementById('receiverCallsign').value);
                  });
        
                const fileServerCheckbox = document.getElementById('isFileServer');
		const pathSection = document.getElementById('pathSection');

		  if (fileServerCheckbox.checked) {
   			 pathSection.style.display = 'block';
		  } else {
			    pathSection.style.display = 'none';
		  }

                const listButtonContainer = document.getElementById('listButtonContainer');
	if (document.getElementById('connectionType').value === 'serial') {
	   document.getElementById('serialSettings').style.display = 'block';
	}        

  const webViewModalEl = document.getElementById('webViewModal');
  webViewModalEl.addEventListener('show.bs.modal', function() {
    autoSaveFilesEnabled = false;
    console.log("Web view modal opened: auto-save disabled.");
  });
  webViewModalEl.addEventListener('hidden.bs.modal', function() {
    autoSaveFilesEnabled = true;
    console.log("Web view modal closed: auto-save enabled.");
  });


if (fileServerCheckbox.checked) {
  // Existing List Files button
  const listBtn = document.createElement('button');
  listBtn.id = "listFilesBtn";
  listBtn.className = "btn btn-info btn-sm ms-2";
  listBtn.innerText = "List Files";
  listBtn.addEventListener('click', openListFilesModal);
  listButtonContainer.appendChild(listBtn);
  
  // New View Web button
  const viewWebBtn = document.createElement('button');
  viewWebBtn.id = "viewWebBtn";
  viewWebBtn.className = "btn btn-info btn-sm ms-2";
  viewWebBtn.innerText = "View Web";
  viewWebBtn.addEventListener('click', openWebViewModal);
  listButtonContainer.appendChild(viewWebBtn);
}
        updateListFilesButtonStatus();
        
        document.getElementById('senderCallsign').addEventListener('input', updateListFilesButtonStatus);
    document.getElementById('receiverCallsign').addEventListener('input', updateListFilesButtonStatus);
    
        
fileServerCheckbox.addEventListener('change', function() {
  // Clear the container first.
  listButtonContainer.innerHTML = "";
  if (this.checked) {
    // Create the List Files button.
    const listBtn = document.createElement('button');
    listBtn.id = "listFilesBtn";
    listBtn.className = "btn btn-info btn-sm ms-2";
    listBtn.innerText = "List Files";
    listBtn.addEventListener('click', openListFilesModal);
    listButtonContainer.appendChild(listBtn);
    
    // Create the View Web button.
    const viewWebBtn = document.createElement('button');
    viewWebBtn.id = "viewWebBtn";
    viewWebBtn.className = "btn btn-info btn-sm ms-2";
    viewWebBtn.innerText = "View Web";
    viewWebBtn.addEventListener('click', openWebViewModal);
    listButtonContainer.appendChild(viewWebBtn);

    pathSection.style.display = 'block';
    
    updateListFilesButtonStatus();
  } else {
	pathSection.style.display = 'none';
  }
});

document.getElementById('createDirectoryBtn').addEventListener('click', function() {
    const pathValue = document.getElementById('pathInput').value.trim();
    if (!pathValue) {
      alert("Please enter a directory path.");
      return;
    }
    // Open the CMD/RSP modal.
    const cmdModal = openCmdRspModal();
    document.getElementById('cmdSentCmdRsp').innerText = "CMD: MKD " + pathValue;
    document.getElementById('rspResponseCmdRsp').innerText = "";
    
    // Send the MKD command using your existing sendCmdWithRetry logic.
    sendCmdWithRetry("MKD " + pathValue)
      .then(rsp => {
        document.getElementById('rspResponseCmdRsp').innerText =
          "RSP: " + (rsp.status === 1 ? "Success" : "Failure") + " - " + rsp.message;
        setTimeout(() => {
          closeCmdRspModal();
        }, 1000);
      })
      .catch(err => {
        document.getElementById('rspResponseCmdRsp').innerText = "Error: " + err;
      });
  });

        
                  const autoCheckbox = document.getElementById('autoBurstCheckbox');
                  const burstSlider = document.getElementById('burstSlider');
                  burstSlider.disabled = autoCheckbox.checked;
                  autoCheckbox.addEventListener('change', function() {
                    burstSlider.disabled = this.checked;
                  });
                
                  updateReceivedFilesUI();
                  updateSentFilesUI();
                  if (document.getElementById('connectionType').value === 'websockets') {
                    initializeWebSocket();
                  }
                  document.getElementById('connectionType').addEventListener('change', async function(e) {
                    const connectionType = e.target.value;
                    if (connectionType === 'serial') {
                      document.getElementById('serialSettings').style.display = 'block';
                      if (socket) {
                        socket.disconnect();
                        socket = null;
                        console.log("Websocket closed (serial selected).");
                      }
                      updateConnectionIndicator();
                    } else {
                      document.getElementById('serialSettings').style.display = 'none';
                      if (serialPort) {
                        try { await serialPort.close(); console.log("Serial port closed."); }
                        catch (err) { console.error("Error closing serial port:", err); }
                        serialPort = null;
                        serialWriter = null;
                        serialConnected = false;
                      }
                      if (!socket) initializeWebSocket();
                      updateConnectionIndicator();
                    }
                  });
                  document.getElementById('serialConnectBtn').addEventListener('click', async () => {
                    if ("serial" in navigator) {
                      try {
                        serialPort = await navigator.serial.requestPort();
                        const baudRate = parseInt(document.getElementById('baudRate').value, 10);
                        await serialPort.open({ baudRate: baudRate });
                        serialConnected = true;
                        serialWriter = serialPort.writable.getWriter();
                        readSerial();
                        updateStatus("Serial port connected at " + baudRate);
                        updateConnectionIndicator();
                        document.getElementById('serialConnectBtn').style.display = 'none';
                        document.getElementById('serialDisconnectBtn').style.display = 'inline-block';
                      } catch (error) {
                        console.error("Error opening serial port:", error);
                        alert("Failed to open serial port: " + error);
                        serialConnected = false;
                        updateConnectionIndicator();
                      }
                    } else {
                      alert("Web Serial API not supported in this browser. Try using Google Chrome");
                      serialConnected = false;
                      updateConnectionIndicator();
                    }
                  });
    	document.getElementById('serialDisconnectBtn').addEventListener('click', async () => {
      if (serialPort) {
        try {
          // Signal the read loop to stop.
          stopReading = true;
    if (serialReader) {
      await serialReader.cancel().catch(err => console.warn("Cancel error:", err));
      if (serialReader && typeof serialReader.releaseLock === 'function') {
        serialReader.releaseLock();
      }
      serialReader = null;
    }
    
          if (serialWriter) {
            serialWriter.releaseLock();
            serialWriter = null;
          }
          await serialPort.close();
          console.log("Serial port closed.");
          serialPort = null;
          serialConnected = false;
          updateConnectionIndicator();
          document.getElementById('serialConnectBtn').style.display = 'inline-block';
          document.getElementById('serialDisconnectBtn').style.display = 'none';
          // Reset the flag for future connections.
          stopReading = false;
        } catch (err) {
          console.error("Error closing serial port:", err);
        }
      }
    });
    

        document.getElementById('sendFileBtn').addEventListener('click', () => {
  // Reset burst counters, etc.
  if (fileTransferInProgress) {
    alert("A file transfer is already in progress.");
    return;
  }
  document.getElementById('sendFileBtn').disabled = true;

  // Validate inputs.
  const inputs = validateFileTransferInputs();
  if (!inputs) {
    document.getElementById('sendFileBtn').disabled = false;
    return;
  }
  sender = inputs.sender;
  receiver = inputs.receiver;
  const file = inputs.file;

  // Get additional options.
  const compress = document.getElementById('compressCheckbox').checked;
  const encodingMethod = document.getElementById('encodingMethod').value;

  // Get the path value (if any) from the new input.
  const pathValue = document.getElementById('pathInput').value.trim();
  let finalFileName = file.name;
  if (pathValue !== "") {
    // Ensure a trailing slash is present.
    if (!pathValue.endsWith('/')) {
      finalFileName = pathValue + "/" + file.name;
    } else {
      finalFileName = pathValue + file.name;
    }
  }

  // Set up burst settings.
  configureBurstSettings();

  if (document.getElementById('isFileServer').checked) {
    // File server mode: use the modified file name in the PUT command.
    const cmdModal = openCmdRspModal();
    document.getElementById('cmdSentCmdRsp').innerText = "CMD: PUT " + finalFileName;
    document.getElementById('rspResponseCmdRsp').innerText = "";

    sendCmdWithRetry("PUT " + finalFileName)
      .then(rsp => {
        document.getElementById('rspResponseCmdRsp').innerText =
          "RSP: " + (rsp.status === 1 ? "Success" : "Failure") + " - " + rsp.message;
        if (rsp.status === 1) {
          fileId = rsp.cmdID;
          setTimeout(() => {
            closeCmdRspModal();
            document.getElementById('senderProgress').scrollIntoView({ behavior: 'smooth' });
            startTransfer(fileId);
            prepareFileTransferData(file, compress, encodingMethod, fileId)
              .then(data => {
                initiateFileTransfer(data, file, sender, receiver, fileId);
              })
              .catch(err => {
                updateStatus("Error reading file: " + err);
                document.getElementById('sendFileBtn').disabled = false;
              });
          }, 1000);
        } else {
          document.getElementById('sendFileBtn').disabled = false;
        }
      })
      .catch(err => {
        document.getElementById('rspResponseCmdRsp').innerText = "Error: " + err;
        document.getElementById('sendFileBtn').disabled = false;
      });
  } else {
    // Normal file transfer: send file as usual.
    fileId = generateTwoCharID();
    startTransfer(fileId);
    prepareFileTransferData(file, compress, encodingMethod, fileId)
      .then(data => {
        initiateFileTransfer(data, file, sender, receiver, fileId);
      })
      .catch(err => {
        updateStatus("Error reading file: " + err);
        document.getElementById('sendFileBtn').disabled = false;
      });
  }
});

        
        
        
        
                  document.getElementById('burstSlider').addEventListener('input', function() {
                    let burstValue = dynamicBurstSizes[parseInt(this.value, 10)];
                    document.getElementById('burstValue').textContent = burstValue;
                  });
                  document.getElementById('autoBurstCheckbox').addEventListener('change', function() {
                    document.getElementById('burstSlider').disabled = this.checked;
                  });
                
		setInterval(() => { 
		  updateReceiverProgressUI();
		  // If the web view modal is open, update its progress bar too.
		  if (document.getElementById('webViewModal').classList.contains('show')) {
		    updateModalProgressBar();
		  }
		}, 1000);
                });
                
                function updateStatus(msg) {
                  document.getElementById('status').innerText = msg;
                  console.log(msg);
                }
    		window.downloadReceivedFile = function(fileId) {
  		const file = persistentReceivedFiles.find(f =>
		    f.fileId === fileId && f.fileName.trim() !== "LIST.txt"
		  );
		  if (!file) return;
		  const a = document.createElement('a');
		  a.href = file.dataUrl;
		  
		  // Extract only the filename after the last slash, if any.
		  let downloadFileName = file.fileName;
		  if (downloadFileName.indexOf('/') !== -1) {
		    downloadFileName = downloadFileName.substring(downloadFileName.lastIndexOf('/') + 1);
		  }
		  a.download = downloadFileName;
		  
		  document.body.appendChild(a);
		  a.click();
		  document.body.removeChild(a);
		};
    
                window.clearSentFile = function(index) {
                  persistentSentFiles.splice(index, 1);
                  saveSentFilesToLocalStorage(persistentSentFiles);
                  updateSentFilesUI();
                };
                window.deleteReceivedFile = function(index) {
                  persistentReceivedFiles.splice(index, 1);
                  saveReceivedFilesToLocalStorage(persistentReceivedFiles);
                  updateReceivedFilesUI();
                };
                window.reAckTransfer = function(key) {
                  let transfer = activeTransfers[key];
                  if (!transfer) return;
                  const senderStr = key.split("_")[0];
                  const fileId = key.split("_")[1];
                  console.log("[Re-ACK] Manually resending cumulative ACK for:", key);
                  sendCumulativeAck(transfer, senderStr, fileId, true);
                };
                function cancelReceiverTransfer(key) {
                  let transfer = activeTransfers[key];
                  if (!transfer) return;
                  
                  if (transfer.ackTimer) {
                    clearTimeout(transfer.ackTimer);
                    transfer.ackTimer = null;
                  }
                  
                  updateStatus("Receiver transfer " + key + " canceled.");
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                }
                
                function manualResend() {
                  console.log("Manual Re-Send triggered by sender. Resending missing packets...");
                  sendBurstPackets();
                }
                
function cancelSenderTransfer() {
  console.log("cancelSenderTransfer() called at", Date.now());
  if (fileTransferInProgress) {
    fileTransferInProgress = false;
    if (ackTimer) {
      console.log("Clearing ackTimer in cancelSenderTransfer");
      clearTimeout(ackTimer);
    }
    if (headerAckTimer) {
      console.log("Clearing headerAckTimer in cancelSenderTransfer");
      clearTimeout(headerAckTimer);
    }
    updateStatus("File transfer canceled.");
    updateSenderProgressUI();
    document.getElementById('sendFileBtn').disabled = false;
    expectedFileId = null;
  }
}


              document.getElementById('senderCallsign').addEventListener('input', function() {
              this.value = this.value.toUpperCase();
              });
            
              document.getElementById('receiverCallsign').addEventListener('input', function() {
              this.value = this.value.toUpperCase();
              });
              // Periodically check for transfers that haven't received new packets and force an ACK resend.
              setInterval(() => {
              const now = Date.now();
              for (const key in activeTransfers) {
                const transfer = activeTransfers[key];
                // Skip transfers that are already finalized.
                if (transfer.finalHandshakeReceived || transfer.completed) continue;
             
                
                // Check if maximum ACK retries have been reached.
                if (transfer.ackRetryCount >= transfer.maxAckRetries) {
                  console.log(`Receiver: Maximum ACK retries reached for transfer ${key} (retry ${transfer.ackRetryCount} of ${transfer.maxAckRetries}). Aborting transfer.`);
                  delete activeTransfers[key];
                  updateReceiverProgressUI();
                  updateStatus("Receiver: Transfer for file " + transfer.header.fileId + " aborted due to ACK timeout.");
                  continue;
                }
                
                // If enough time has passed since the last packet, force a resend.
                if (now - transfer.lastPacketTime > transfer.ackDelay) {
                  // Increment the retry counter here.
                  transfer.ackRetryCount++;
                  console.log(`Periodic check: ACK retry attempt ${transfer.ackRetryCount} for transfer ${key} (max ${transfer.maxAckRetries}). Resending ACK.`);
                  sendCumulativeAck(transfer, key.split("_")[0], transfer.header.fileId, true);
                  // Update the last packet time to prevent too-frequent retries.
                  transfer.lastPacketTime = now;
                }
              }
              }, 1000);
        
        
    
    
        
        // Build a CMD packet given your callsigns and command text.
function buildCmdPacket(myCallsign, fileServerCallsign, commandText) {
  const header = buildAX25Header(myCallsign, fileServerCallsign);
  const cmdID = generateTwoCharID();
  // New format: "cmdID:CMD:<command text>"
  let infoStr = `${cmdID}:CMD:${commandText}`;
  const encoder = new TextEncoder();
  const infoBytes = encoder.encode(infoStr); // No fixed-length padding/truncation
  const packet = new Uint8Array(header.length + infoBytes.length);
  packet.set(header, 0);
  packet.set(infoBytes, header.length);
  return { packet, cmdID };
}

        
function parseRspPacket(payload) {
  // Assume 'payload' is a Uint8Array containing the variable-length RSP info field.
  const decoder = new TextDecoder();
  const str = decoder.decode(payload).trim();
  
  // Expected new format: "cmdID:RSP:<status>:<message>"
  const parts = str.split(":", 4);
  if (parts.length < 4) {
    return { ok: false, error: "Incomplete RSP packet" };
  }
  const cmdID = parts[0];
  if (parts[1].toUpperCase() !== "RSP") {
    return { ok: false, error: "Not an RSP packet" };
  }
  const status = parseInt(parts[2], 10);
  if (isNaN(status)) {
    return { ok: false, error: "Invalid status value" };
  }
  const message = parts[3];
  return { ok: true, cmdID, status, message };
}

        
        // Optional: Send a CMD packet over the active connection and wait for its corresponding RSP.
        // This function uses a pending responses map to associate incoming responses with sent commands.
        const pendingCmdResponses = {};
        
        function sendCmd(commandText) {
          return new Promise((resolve, reject) => {
            // Read the callsigns from the UI fields.
            const myCallsign = document.getElementById('senderCallsign').value.trim();
            const fileServerCallsign = document.getElementById('receiverCallsign').value.trim();
            // Build the CMD packet.
            const { packet, cmdID } = buildCmdPacket(myCallsign, fileServerCallsign, commandText);
            // Wrap the packet in a KISS frame.
            const kissFrame = buildKissFrame(packet);
            
            // Store the promise resolvers keyed by the command ID.
            pendingCmdResponses[cmdID] = { resolve, reject, timestamp: Date.now() };
            
            // Send the frame via websockets or serial.
            if (document.getElementById('connectionType').value === 'websockets') {
              if (socket) socket.emit('raw_kiss_frame', kissFrame);
              else reject("No websocket connection available.");
            } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
              serialWriter.write(kissFrame).catch(err => reject(err));
            } else {
              reject("No valid connection available.");
            }
            
            // Optionally, set a timeout to reject the promise if no response arrives in time.
            const timeoutMS = (parseFloat(document.getElementById('timeoutSeconds').value) * 1000) || 10000;
            setTimeout(() => {
              if (pendingCmdResponses[cmdID]) {
                delete pendingCmdResponses[cmdID];
                reject("Timeout for CMD ID " + cmdID);
              }
            }, timeoutMS);
          });
        }
    
    function sendCmdWithRetry(commandText, maxRetries) {
      // If maxRetries isn't provided, read it from the "Timeout Retries" input box.
      maxRetries = maxRetries !== undefined ? maxRetries : (parseInt(document.getElementById('timeoutRetries').value, 10) || 3);
    
      return new Promise((resolve, reject) => {
        let attempts = 0;
        const myCallsign = document.getElementById('senderCallsign').value.trim();
        const fileServerCallsign = document.getElementById('receiverCallsign').value.trim();
        const { packet, cmdID } = buildCmdPacket(myCallsign, fileServerCallsign, commandText);
    
        const sendCmdPacket = () => {
          attempts++;
          console.log(`Sending CMD attempt ${attempts}: ${commandText}`);
          // Store the promise resolvers under the fixed cmdID.
          pendingCmdResponses[cmdID] = { resolve, reject, timestamp: Date.now() };
          const kissFrame = buildKissFrame(packet);
          if (document.getElementById('connectionType').value === 'websockets') {
            if (socket) socket.emit('raw_kiss_frame', kissFrame);
            else reject("No websocket connection available.");
          } else if (document.getElementById('connectionType').value === 'serial' && serialWriter) {
            serialWriter.write(kissFrame).catch(err => reject(err));
          } else {
            reject("No valid connection available.");
          }
        };
    
        const attemptSend = () => {
          sendCmdPacket();
          // Get timeout from the UI (in seconds) and convert to milliseconds.
          const timeoutMS = (parseFloat(document.getElementById('timeoutSeconds').value) * 1000) || 10000;
          setTimeout(() => {
            if (pendingCmdResponses[cmdID]) {
              if (attempts < getMaxRetries()) {
                console.log(`No RSP within timeout. Retrying CMD "${commandText}" (attempt ${attempts + 1}/${maxRetries})`);
                attemptSend();
              } else {
                delete pendingCmdResponses[cmdID];
                reject(`No RSP after ${attempts} attempts.`);
              }
            }
          }, timeoutMS);
        };
    
        attemptSend();
      });
    }
    
function openListFilesModal() {
  // Clear previous command, response text, and table.
  document.getElementById('cmdSentList').innerText = "";
  document.getElementById('rspResponseList').innerText = "";
  document.getElementById('listTable').innerHTML = "";
  
  const modalTitle = document.getElementById('listFilesLabel');
  
  let refreshBtn = document.getElementById('refreshListBtn');
  if (!refreshBtn) {
    refreshBtn = document.createElement('button');
    refreshBtn.id = 'refreshListBtn';
    refreshBtn.className = 'btn btn-danger btn-sm ms-2';
    refreshBtn.innerText = 'Refresh List';
    refreshBtn.style.display = 'none'; // keep it hidden initially
   refreshBtn.addEventListener('click', function() {
     // Immediately hide the button while the refresh is in progress.
     this.style.display = 'none';
     cachedListCSV = null;
     document.getElementById('cmdSentList').innerText = "CMD: LIST";
     document.getElementById('listTable').innerHTML = '<p>Waiting for file list...</p>';
     fetchListFiles();
   });
    modalTitle.insertAdjacentElement('afterend', refreshBtn);
  }
  
  // Do not set refreshBtn.style.display here!
  
  const listFilesModal = new bootstrap.Modal(document.getElementById('listFiles'));
  listFilesModal.show();
  
  if (cachedListCSV) {
    processListFile(cachedListCSV);
  } else {
    document.getElementById('cmdSentList').innerText = "CMD: LIST";
    document.getElementById('listTable').innerHTML = '<p>Waiting for file list...</p>';
    fetchListFiles();
  }
}


        
        
    function processListFile(csvText) {
      // Cache the CSV text so that we can reuse it on subsequent modal openings.
      cachedListCSV = csvText;
    
      // Split into lines and filter out empty ones.
      const lines = csvText.split('\n').filter(line => line.trim() !== '');
      if (lines.length === 0) return;
    
      // Build a search input box.
      let searchBoxHtml = `<input type="text" id="listSearchBox" class="form-control mb-3" placeholder="Search files...">`;
    
      // Build the table HTML.
      let tableHtml = '<div class="table-responsive"><table id="listFilesTable" class="table table-striped table-hover table-bordered"><thead><tr>';
      // Assume the first line is the header.
      const headers = lines[0].split(',');
      headers.forEach(header => {
        tableHtml += '<th>' + header.replace(/"/g, '') + '</th>';
      });
      tableHtml += '<th>Action</th></tr></thead><tbody>';
    
      // Process each subsequent row.
      for (let i = 1; i < lines.length; i++) {
        const cols = lines[i].split(',');
        if (cols.length < 3) continue;
        tableHtml += '<tr>';
        cols.forEach(col => {
          tableHtml += '<td>' + col.replace(/"/g, '') + '</td>';
        });
        // Use the file name from the first column (without quotes).
        const fileName = cols[0].replace(/"/g, '');
	tableHtml += '<td>';
	if (fileName.endsWith('/')) {
	  // Render a placeholder span that takes up space but is invisible.
	  tableHtml += '<span class="btn btn-primary btn-sm" style="visibility: hidden;">Get</span> ';
	} else {
	  // Render the actual Get button.
	  tableHtml += '<button class="btn btn-primary btn-sm" onclick="getFile(\'' + fileName + '\')">Get</button> ';
	}
	tableHtml += '<button class="btn btn-warning btn-sm me-2" onclick="renameFile(\'' + fileName + '\')">Rename</button> ';
	tableHtml += '<button class="btn btn-danger btn-sm" onclick="deleteFile(\'' + fileName + '\')">Delete</button> ';
	tableHtml += '</td>';
        tableHtml += '</tr>';
      }
      tableHtml += '</tbody></table></div>';
    
      // Combine search box and table in the modal's listTable container.
      document.getElementById('listTable').innerHTML = searchBoxHtml + tableHtml;
      const refreshBtn = document.getElementById('refreshListBtn');
      if (refreshBtn) {
        refreshBtn.style.display = 'inline-block';
      }
    
      // Add search functionality.
    document.getElementById('listSearchBox').addEventListener('keyup', function () {
      const filter = this.value.toUpperCase();
      const table = document.getElementById('listFilesTable');
      const tr = table.getElementsByTagName('tr');
      // Skip the header row.
      for (let i = 1; i < tr.length; i++) {
        const firstCell = tr[i].getElementsByTagName('td')[0];
        if (firstCell) {
          let cellText = firstCell.textContent || firstCell.innerText;
          tr[i].style.display = cellText.toUpperCase().indexOf(filter) > -1 ? "" : "none";
        }
      }
    });  
    
    
      // Main table-sorting function that uses localeCompare for all columns.
      function sortTableByColumn(table, columnIndex, asc = true) {
        const tbody = table.tBodies[0];
        const rows = Array.from(tbody.querySelectorAll("tr"));
        rows.sort((a, b) => {
          const aText = a.children[columnIndex].textContent.trim();
          const bText = b.children[columnIndex].textContent.trim();
          return asc
            ? aText.localeCompare(
                bText,
                navigator.languages[0] || navigator.language,
                { numeric: true, ignorePunctuation: true }
              )
            : bText.localeCompare(
                aText,
                navigator.languages[0] || navigator.language,
                { numeric: true, ignorePunctuation: true }
              );
        });
        // Append the sorted rows back into the tbody.
        rows.forEach(row => tbody.appendChild(row));
      }
    
      // Attach click listeners to header cells (except the last "Action" column).
      const table = document.getElementById("listFilesTable");
      const headerCells = table.querySelectorAll("thead th");
      headerCells.forEach((th, index) => {
        // Skip the "Action" column (assumed to be the last header cell).
        if (index === headerCells.length - 1) return;
        th.style.cursor = 'pointer';
        // Use a data attribute to track the current sort order.
        th.setAttribute("data-sort-asc", "true");
        th.addEventListener("click", function() {
          let currentAsc = th.getAttribute("data-sort-asc") === "true";
          sortTableByColumn(table, index, currentAsc);
          // Toggle sort order for next click.
          th.setAttribute("data-sort-asc", (!currentAsc).toString());
        });
      });
    }
    
    
        
        
        // New function: when a Get button is clicked.
function getFile(fileName) {
  // Hide the refresh button when the GET command is triggered.
  const refreshBtn = document.getElementById('refreshListBtn');
  if (refreshBtn) {
    refreshBtn.style.display = 'none';
  }

  // Update the modal's top CMD display.
  document.getElementById('cmdSentList').innerText = "CMD: GET " + fileName;
  // Clear any previous response and table.
  document.getElementById('rspResponseList').innerText = "";
  document.getElementById('listTable').innerHTML = "";
  
  // Send the GET command.
  sendCmdWithRetry("GET " + fileName)
    .then(rsp => {
      const statusText = (rsp.status === 1) ? "Success" : "Failed";
      document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
      
      // If the response indicates failure, show an overlay error in the web view modal.
      if (rsp.status !== 1) {
        console.log("GET RSP failed with message:", rsp.message);
        const webViewModal = document.getElementById('webViewModal');
        if (webViewModal && webViewModal.classList.contains('show')) {
          showWebViewErrorOverlay("GET failed: " + rsp.message);
        }
        // Also update the global status if desired.
        updateStatus("GET failed: " + rsp.message);
      }
      
      // If the response indicates success, proceed as usual.
      if (rsp.status === 1) {
        expectedFileId = rsp.cmdID;
        console.log("Expected file ID set to:", expectedFileId);
        setTimeout(() => {
          const modalEl = document.getElementById('listFiles');
          const modalInstance = bootstrap.Modal.getInstance(modalEl);
          if (modalInstance) {
            modalInstance.hide();
          }
          document.getElementById('receiverProgress').scrollIntoView({ behavior: 'smooth' });
        }, 1000);
      }
    })
  .catch(err => {
    console.log("GET command failed with error:", err); // <-- Add this log
    document.getElementById('rspResponseList').innerText = "Error: " + err;
    updateStatus("Error sending GET: " + err);
    const webViewModal = document.getElementById('webViewModal');
    if (webViewModal && webViewModal.classList.contains('show')) {
      console.log("Modal is open; calling showWebViewErrorOverlay"); // <-- Log here too
      showWebViewErrorOverlay("Error sending GET: " + err);
    }
  });
}


        
        
        function fetchListFiles() {
          sendCmdWithRetry("LIST")
            .then(rsp => {
              const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
              document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
    	  if (rsp.status === 1) {
    		expectedFileId = rsp.cmdID;
    		console.log("Expected file ID for LIST set to:", expectedFileId);
    	  }
            })
            .catch(err => {
              document.getElementById('rspResponseList').innerText = "Error: " + err;
            });
        }
        function openCmdRspModal() {
          const modalEl = document.getElementById('cmdRspModal');
          const modalInstance = new bootstrap.Modal(modalEl, { backdrop: 'static', keyboard: false });
          modalInstance.show();
          return modalInstance;
        }
        
        function closeCmdRspModal() {
          const modalEl = document.getElementById('cmdRspModal');
          const modalInstance = bootstrap.Modal.getInstance(modalEl);
          if (modalInstance) {
            modalInstance.hide();
          }
        }
        function validateFileTransferInputs() {
          const sender = document.getElementById('senderCallsign').value.trim();
          const receiver = document.getElementById('receiverCallsign').value.trim();
          const fileInput = document.getElementById('fileInput');
          if (!sender || !receiver || !fileInput.files.length) {
            alert("Ensure your callsign, remote callsign and a file has been selected.");
            return null;
          }
          return { sender, receiver, file: fileInput.files[0] };
        }
        function configureBurstSettings() {
          if (document.getElementById('autoBurstCheckbox').checked) {
            burstSize = 0;
            currentDynamicBurstIndex = 2; // default to index 2 (i.e. burst size 4)
            currentBurstSizeDynamic = dynamicBurstSizes[currentDynamicBurstIndex];
          } else {
            const sliderIndex = parseInt(document.getElementById('burstSlider').value, 10);
            burstSize = dynamicBurstSizes[sliderIndex];
          }
        }
        function prepareFileTransferData(file, compress, encodingMethod, fileId) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = function(e) {
              const arrayBuffer = e.target.result;
              const fileData = new Uint8Array(arrayBuffer);
              let finalData;
              try {
                finalData = compress ? pako.deflate(fileData, { level: 9 }) : fileData;
              } catch (err) {
                reject(err);
                return;
              }
              const md5 = CryptoJS.MD5(CryptoJS.lib.WordArray.create(fileData)).toString();
              const fileDataChunksCount = Math.ceil(finalData.length / CHUNK_SIZE);
              const totalPacketsExpected = fileDataChunksCount;
              
              // Read timeout values from UI
              const timeoutSeconds = parseFloat(document.getElementById('timeoutSeconds')?.value) || 5.0;
              const timeoutRetries = parseInt(document.getElementById('timeoutRetries')?.value, 10) || 5;
              
              // Build header string (fields separated by "|")
              const headerStr = timeoutSeconds + "|" +
                                timeoutRetries + "|" +
                                file.name + "|" +
                                fileData.length + "|" +
                                finalData.length + "|" +
                                md5 + "|" +
                                fileId + "|" +
                                (encodingMethod === 'base64' ? "1" : "0") + "|" +
                                (compress ? "1" : "0") + "|" +
                                (totalPacketsExpected + 1);
              const headerPayload = new TextEncoder().encode(headerStr);
              
              // Split the file data into chunks.
              const chunks = [];
              chunks.push(headerPayload); // packet 1 (header)
              for (let i = 0; i < fileDataChunksCount; i++) {
                const start = i * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, finalData.length);
                let chunk = finalData.slice(start, end);
                if (encodingMethod === 'base64') {
                  let binaryString = "";
                  for (let j = 0; j < chunk.length; j++) {
                    binaryString += String.fromCharCode(chunk[j]);
                  }
                  let base64Str = btoa(binaryString);
                  chunk = new TextEncoder().encode(base64Str);
                }
                chunks.push(chunk);
              }
              
              resolve({
                fileDataChunks: chunks,
                totalPackets: chunks.length,
                md5,
                originalSize: fileData.length,
                compressedSize: finalData.length,
                timeoutSeconds,
                timeoutRetries
              });
            };
            reader.onerror = function(e) {
              reject(e);
            };
            reader.readAsArrayBuffer(file);
          });
        }
        function initiateFileTransfer(data, file, sender, receiver, fileId) {
          fileDataChunks = data.fileDataChunks;
          totalPackets = data.totalPackets;
          currentPacketIndex = 0;
          currentRetries = 0;
          totalRetries = 0;
          fileTransferInProgress = true;
          headerAckReceived = false;
          burstInProgress = false;
          missingPackets = [];
          highestPacketSentSoFar = 0;
          
          sentFileStats = {
            fileName: file.name,
            receiver: receiver,
            originalSize: data.originalSize,
            compressedSize: data.compressedSize,
            startTime: Date.now(),
            totalRetries: 0,
            bytesSent: 0,
            totalPackets: totalPackets,
            fileId: fileId
          };
          
          updateStatus(`File compressed from ${data.originalSize} bytes to ${data.compressedSize} bytes.
        File ID: ${fileId}`);
          updateSenderProgressUI();
          
          // Initialize header retry variables and send header packet (sequence 1)
          headerRetryCount = 0;
          headerAckReceived = false;
          headerSentTimestamp = Date.now();
          defaultHeaderTimeout = defaultPerPacketTimeout + (data.timeoutSeconds * 1000);
          console.log("Sending header packet (seq 1)");
          sendPacket(1);
          headerAckTimer = setTimeout(waitForHeaderAck, defaultHeaderTimeout);
        }
    
    
 function deleteFile(fileName) {
  const refreshBtn = document.getElementById('refreshListBtn');
  if (refreshBtn) {
    refreshBtn.style.display = 'none';
  }
  
  let confirmationMessage = "";
  if (fileName.endsWith('/')) {
    confirmationMessage = "Are you sure you want to delete the entire directory " + fileName + "?";
  } else {
    confirmationMessage = "Are you sure you want to delete " + fileName + "?";
  }
  
  if (confirm(confirmationMessage)) {
    // Update the modal's command display.
    document.getElementById('cmdSentList').innerText = "CMD: DEL " + fileName;
    // Clear previous response and table.
    document.getElementById('rspResponseList').innerText = "";
    document.getElementById('listTable').innerHTML = "";
    
    // Send the DEL command.
    sendCmdWithRetry("DEL " + fileName)
      .then(rsp => {
        const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
        document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
        // If successful, show "Waiting for file list..." and then refresh.
        if (rsp.status === 1) {
          setTimeout(() => {
            document.getElementById('listTable').innerHTML = '<p>Refreshing file list...</p>';
            fetchListFiles();
          }, 1000);
        }
      })
      .catch(err => {
        document.getElementById('rspResponseList').innerText = "Error: " + err;
      });
  }
}

    
    function renameFile(fileName) {
      const refreshBtn = document.getElementById('refreshListBtn');
      if (refreshBtn) {
        refreshBtn.style.display = 'none';
      }
      const newName = prompt("Enter new filename for " + fileName + ":", fileName);
      if (newName && newName.trim() !== "" && newName !== fileName) {
        // Update the modal's command display.
        document.getElementById('cmdSentList').innerText = "CMD: REN " + fileName + "|" + newName;
        // Clear previous response and table.
        document.getElementById('rspResponseList').innerText = "";
        document.getElementById('listTable').innerHTML = "";
        
        // Send the REN command.
        sendCmdWithRetry("REN " + fileName + "|" + newName)
          .then(rsp => {
            const statusText = (rsp.status === 1) ? "Success" : (rsp.status === 0 ? "Failed" : "Unknown");
            document.getElementById('rspResponseList').innerText = "RSP: " + statusText + " - " + rsp.message;
            // If successful, show "Waiting for file list..." and then refresh.
            if (rsp.status === 1) {
              setTimeout(() => {
                document.getElementById('listTable').innerHTML = '<p>Refreshing file list...</p>';
                fetchListFiles();
              }, 1000);
            }
          })
          .catch(err => {
            document.getElementById('rspResponseList').innerText = "Error: " + err;
          });
      } else {
        alert("Invalid new filename.");
      }
    }
    
    
function updateListFilesButtonStatus() {
  const sender = document.getElementById('senderCallsign').value.trim();
  const receiver = document.getElementById('receiverCallsign').value.trim();
  const listBtn = document.getElementById('listFilesBtn');
  const viewWebBtn = document.getElementById('viewWebBtn');
  let connectionIsActive = false;
  
  if (document.getElementById('connectionType').value === 'websockets') {
    connectionIsActive = (socket && socket.connected);
  } else {
    connectionIsActive = serialConnected;
  }
  
  // Disable the buttons if either callsign is empty or no active connection
  if (listBtn) {
    listBtn.disabled = !(sender && receiver && connectionIsActive);
  }
  if (viewWebBtn) {
    viewWebBtn.disabled = !(sender && receiver && connectionIsActive);
  }
}

    
    function generateTwoCharID() {
      const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
      return chars.charAt(Math.floor(Math.random() * chars.length)) +
             chars.charAt(Math.floor(Math.random() * chars.length));
    }

window.viewReceivedFile = function(fileId) {
  // Close the web view modal if it's open.
  const webModalEl = document.getElementById('webViewModal');
  const webModalInstance = bootstrap.Modal.getInstance(webModalEl);
  if (webModalInstance) {
    webModalInstance.hide();
  }

  // Find the file based on fileId.
  const file = persistentReceivedFiles.find(f => f.fileId === fileId);
  if (!file) return;

  // Define allowed editable extensions.
  const allowedExtensions = ['.txt', '.html', '.js', '.css'];
  const lowerName = file.fileName.toLowerCase();

  // Check if the file's extension is among the allowed ones.
  const isEditable = allowedExtensions.some(ext => lowerName.endsWith(ext));
  if (!isEditable) {
    alert("The selected file is not an editable text file.");
    return;
  }

  // Store the file for later editing.
  currentViewedFile = file;

  // Fetch and display the file content.
  fetch(file.dataUrl)
    .then(response => response.text())
    .then(text => {
      document.getElementById('fileViewContent').innerText = text;
      const modal = new bootstrap.Modal(document.getElementById('fileViewModal'));
      modal.show();
    })
    .catch(err => {
      console.error("Error loading file content:", err);
    });
};

// Open the modal when the Create Text File button is clicked.
document.getElementById('createTextFileBtn').addEventListener('click', function() {
    const modal = new bootstrap.Modal(document.getElementById('createTextFileModal'));
    modal.show();
});

// When the modal's Send File button is clicked, create a text file and send it.
document.getElementById('modalSendFileBtn').addEventListener('click', function() {
  console.log("Send button clicked in the create file modal.");
  const senderInput = document.getElementById('senderCallsign').value.trim();
  const receiverInput = document.getElementById('receiverCallsign').value.trim();
  const fileNameInput = document.getElementById('textFileName').value.trim();
  const extension = document.getElementById('textFileExtension').value;
  const fileContent = document.getElementById('textFileContent').value;
  
  if (!senderInput || !receiverInput || !fileNameInput || !fileContent) {
    alert("Provide filename and content.");
    return;
  }
  
  // Ensure the final file name ends with the chosen extension.
  let finalFileName = fileNameInput;
  if (!finalFileName.toLowerCase().endsWith(extension.toLowerCase())) {
    finalFileName += extension;
  }
  
  // Create a File object from the content.
  const file = new File([fileContent], finalFileName, { type: 'text/plain' });
  
  // (Your existing file transfer logic follows here...)
  
  // For example:
  if (fileTransferInProgress) {
    alert("A file transfer is already in progress.");
    return;
  }
  
  document.getElementById('sendFileBtn').disabled = true;
  sender = senderInput;
  receiver = receiverInput;
  const compress = document.getElementById('compressCheckbox').checked;
  const encodingMethod = document.getElementById('encodingMethod').value;
  
  configureBurstSettings();
  
  // Branch based on file server mode.
    if (document.getElementById('isFileServer').checked) {
        const cmdModal = openCmdRspModal();
        document.getElementById('cmdSentCmdRsp').innerText = "CMD: PUT " + finalFileName;
        document.getElementById('rspResponseCmdRsp').innerText = "";
        
        sendCmdWithRetry("PUT " + finalFileName)
          .then(rsp => {
             document.getElementById('rspResponseCmdRsp').innerText =
                "RSP: " + (rsp.status === 1 ? "Success" : "Failure") + " - " + rsp.message;
             if (rsp.status === 1) {
                 fileId = rsp.cmdID;
                 setTimeout(() => {
                     closeCmdRspModal();
                     document.getElementById('senderProgress').scrollIntoView({ behavior: 'smooth' });
                     startTransfer(fileId);
                     prepareFileTransferData(file, compress, encodingMethod, fileId)
                       .then(data => {
                           initiateFileTransfer(data, file, sender, receiver, fileId);
                       })
                       .catch(err => {
                           updateStatus("Error reading file: " + err);
                           document.getElementById('sendFileBtn').disabled = false;
                       });
                 }, 1000);
             } else {
                 document.getElementById('sendFileBtn').disabled = false;
             }
          })
          .catch(err => {
             document.getElementById('rspResponseCmdRsp').innerText = "Error: " + err;
             document.getElementById('sendFileBtn').disabled = false;
          });
  } else {
    fileId = generateTwoCharID();
    startTransfer(fileId);
    prepareFileTransferData(file, compress, encodingMethod, fileId)
      .then(data => {
          initiateFileTransfer(data, file, sender, receiver, fileId);
      })
      .catch(err => {
          updateStatus("Error reading file: " + err);
          document.getElementById('sendFileBtn').disabled = false;
      });
  }
  
  // Hide the modal once the file transfer is initiated.
  const modalEl = document.getElementById('createTextFileModal');
  const modalInstance = bootstrap.Modal.getInstance(modalEl);
  if (modalInstance) {
      modalInstance.hide();
  }
});


document.getElementById('clearTextFileBtn').addEventListener('click', function() {
  document.getElementById('textFileName').value = '';
  document.getElementById('textFileContent').value = '';
});

document.getElementById('editFileBtn').addEventListener('click', function() {
  // Get the current text content.
  const fileContent = document.getElementById('fileViewContent').innerText;
  
  if (!currentViewedFile) {
    alert("No file loaded to edit.");
    return;
  }
  
  // Extract the file name and extension.
  let fileName = currentViewedFile.fileName;
  const dotIndex = fileName.lastIndexOf('.');
  let baseName = fileName;
  let ext = '.txt'; // default value
  if (dotIndex !== -1) {
    baseName = fileName.substring(0, dotIndex);
    ext = fileName.substring(dotIndex);
  }
  
  // Set the filename input and the dropdown value.
  document.getElementById('textFileName').value = baseName;
  document.getElementById('textFileExtension').value = ext;
  document.getElementById('textFileContent').value = fileContent;
  
  // Close the current view modal.
  const viewModalEl = document.getElementById('fileViewModal');
  const viewModalInstance = bootstrap.Modal.getInstance(viewModalEl);
  if (viewModalInstance) {
    viewModalInstance.hide();
  }
  
  // Open the create file modal.
  const createModal = new bootstrap.Modal(document.getElementById('createTextFileModal'));
  createModal.show();
});


function openWebViewModal() {
  currentPageName = "index.html";
  document.getElementById('currentPageUrl').value = currentPageName;
  const contentEl = document.getElementById('webViewContent');

  // Show spinner immediately in the modal.
  contentEl.innerHTML = '<div id="spinnerContainer"><div class="spinner"></div></div>';
  (new bootstrap.Modal(document.getElementById('webViewModal'))).show();

  // Instead of calling loadIndexWithAssets directly, always use loadPage.
  if (cachedIndexHTML) {
    // Use loadPage to update history and content.
    loadPage("index.html", cachedIndexHTML);
  } else {
    // Send the GET command and then call loadPage once the HTML is available.
    sendCmdWithRetry("GET index.html")
      .then(rsp => {
        console.log("index.html GET command sent.");
        // Poll until cachedIndexHTML is updated by your packet processing.
        let checkInterval = setInterval(() => {
          if (cachedIndexHTML) {
            clearInterval(checkInterval);
            loadPage("index.html", cachedIndexHTML);
          }
        }, 200);
      })
      .catch(err => {
        contentEl.innerHTML = "<p style='padding: 1rem;'>Error: " + err + "</p>";
      });
  }
}

function fetchAssetViaGET(assetPath) {
  // Normalize the asset path for cache comparison
  const normalizedAssetPath = normalizePath(assetPath);

  // Resolve relative asset paths
  if (!assetPath.match(/^(?:[a-z]+:)?\/\//i) && !assetPath.startsWith('/')) {
    const baseDir = currentPageName.substring(0, currentPageName.lastIndexOf('/') + 1);
    if (!assetPath.startsWith(baseDir)) {
      assetPath = baseDir + assetPath;
    }
  }

  // Normalize the final resolved path for cache lookup
  const finalNormalizedAssetPath = normalizePath(assetPath);

  // Get all cached assets that match the normalized file name
  const matchingAssets = persistentReceivedFiles.filter(f =>
    normalizePath(f.fileName.trim()) === finalNormalizedAssetPath
  );

  // Filter valid assets (ones with a defined dataUrl) and sort them by timestamp (most recent first)
  const validAssets = matchingAssets.filter(asset => asset.dataUrl && !asset.dataUrl.includes("undefined"));
  const cachedAsset = validAssets.sort((a, b) => b.timestamp - a.timestamp)[0];

  if (cachedAsset) {
    console.log("Using cached asset:", cachedAsset.fileName, "with timestamp:", cachedAsset.timestamp);
    return Promise.resolve(cachedAsset.dataUrl);
  }

  // If there's already a pending GET for this asset, return that promise.
  if (pendingGETs[finalNormalizedAssetPath]) {
    return pendingGETs[finalNormalizedAssetPath];
  }

  // Otherwise, create a new promise for the GET request.
  pendingGETs[finalNormalizedAssetPath] = new Promise((resolve, reject) => {
    sendCmdWithRetry("GET " + assetPath)
      .then(() => {
        let attempts = 0;
        const pollInterval = setInterval(() => {
          attempts++;
          const newMatchingAssets = persistentReceivedFiles.filter(f =>
            normalizePath(f.fileName.trim()) === finalNormalizedAssetPath
          );
          const newValidAssets = newMatchingAssets.filter(asset => asset.dataUrl && !asset.dataUrl.includes("undefined"));
          const assetObj = newValidAssets.sort((a, b) => b.timestamp - a.timestamp)[0];
          if (assetObj) {
            clearInterval(pollInterval);
            delete pendingGETs[finalNormalizedAssetPath];
            console.log("Fetched asset:", assetObj.fileName, "with timestamp:", assetObj.timestamp);
            resolve(assetObj.dataUrl);
          } else if (attempts > 300) { // 300 * 200ms = 60 seconds timeout
            clearInterval(pollInterval);
            delete pendingGETs[finalNormalizedAssetPath];
            reject("Asset not ready within timeout: " + assetPath);
          }
        }, 200);
      })
      .catch(err => {
        delete pendingGETs[finalNormalizedAssetPath];
        reject(err);
      });
  });

  // Attach a catch handler to display errors
  pendingGETs[finalNormalizedAssetPath].catch(err => {
    updateStatus("Error loading asset " + assetPath + ": " + err);
  });

  return pendingGETs[finalNormalizedAssetPath];
}

// New function: parse the cached index.html, fetch its assets, then inject modified HTML into the modal.
// Global variable to track the current page name.
currentPageName = "index.html";

// Function to load HTML content with assets.
async function loadIndexWithAssetsSequentially(htmlContent) {
  const parser = new DOMParser();
  const doc = parser.parseFromString(htmlContent, 'text/html');

  // Select asset elements (images, scripts, stylesheets)
  const assetElements = doc.querySelectorAll('img[src], script[src], link[rel="stylesheet"][href], audio[src], source[src]');
  const totalAssets = assetElements.length;
  let loadedAssets = 0;

  // Sequentially fetch each asset
  for (const el of assetElements) {
    const tagName = el.tagName.toLowerCase();
    const assetUrl = tagName === 'link' ? el.getAttribute('href') : el.getAttribute('src');
    try {
      const dataUrl = await fetchAssetViaGET(assetUrl);
      if (tagName === 'img' || tagName === 'script') {
        el.setAttribute('src', dataUrl);
      } else if (tagName === 'link') {
        el.setAttribute('href', dataUrl);
      } else if (tagName === 'audio' || (tagName === 'source' && el.getAttribute('type') === 'audio/mpeg')) {
  	el.setAttribute('src', dataUrl);
      }
      loadedAssets++;
      // Optionally update progress here
    } catch (err) {
      console.error("Error fetching asset:", assetUrl, err);
      loadedAssets++;
    }
  }

  // Inject the modified HTML into the modal
  document.getElementById('webViewContent').innerHTML = doc.documentElement.outerHTML;
  document.getElementById('currentPageUrl').value = currentPageName;
  setupModalLinks();
}




// Event listener for the Home button.
document.getElementById('navHomeBtn').addEventListener('click', () => {
  const homePage = "index.html"; // Always use the root index.html
  currentPageName = homePage;
  document.getElementById('currentPageUrl').value = homePage;
  
  // Show spinner
  document.getElementById('webViewContent').innerHTML =
    '<div id="spinnerContainer"><div class="spinner"></div></div>';
  
  // Fetch and load index.html
  fetchAssetViaGET(homePage)
    .then(dataUrl => fetch(dataUrl))
    .then(response => response.text())
    .then(htmlContent => {
      loadIndexWithAssetsSequentially(htmlContent);
    })
    .catch(err => console.error("Error loading home page:", err));
});


// Event listener for the Refresh button.
document.getElementById('navRefreshBtn').addEventListener('click', () => {
  if (currentPageName) {
    // Remove cached version to force a new GET request.
    persistentReceivedFiles = persistentReceivedFiles.filter(
      file => file.fileName.trim() !== currentPageName
    );
    
    // Immediately display the spinner.
    document.getElementById('webViewContent').innerHTML = '<div id="spinnerContainer"><div class="spinner"></div></div>';
    
    // Fetch the page via GET.
    fetchAssetViaGET(currentPageName)
      .then(dataUrl => fetch(dataUrl))
      .then(response => response.text())
      .then(htmlContent => {
        loadIndexWithAssetsSequentially(htmlContent);
      })
      .catch(err => console.error("Error refreshing page:", err));
  }
});




// Helper function to resolve a URL relative to the current page directory.
function resolveRelativeURL(url, currentPage) {
  // If the URL is already absolute (has a protocol or starts with '/'), return it unchanged.
  if (/^(?:[a-z]+:)?\/\//i.test(url) || url.startsWith('/')) {
    return url;
  }
  // Get the directory portion of the current page.
  // E.g., for "MM3NDH-12/index.html" this gives "MM3NDH-12/"
  let lastSlashIndex = currentPage.lastIndexOf('/');
  let baseDir = (lastSlashIndex !== -1) ? currentPage.substring(0, lastSlashIndex + 1) : '';
  return baseDir + url;
}

// Modified setupModalLinks function:
function setupModalLinks() {
  const modalContent = document.getElementById('webViewContent');
  const links = modalContent.querySelectorAll('a[href]');
  links.forEach(link => {
    link.addEventListener('click', function(e) {
  e.preventDefault();
  // Get the original href from the link.
  const originalHref = this.getAttribute('href');
  // Resolve the URL relative to the current page.
  const resolvedHref = resolveRelativeURL(originalHref, currentPageName);
  document.getElementById('currentPageUrl').value = resolvedHref;

  // If the link should be loaded as a page:
  if (
    resolvedHref.endsWith('.html') ||
    resolvedHref.endsWith('/') ||
    resolvedHref.indexOf('.') === -1
  ) {
    // Simply call loadPageFromUrl which adds "/index.html" if needed.
    loadPageFromUrl(resolvedHref);
  } else {
    // Otherwise, treat it as a file download.
    const flashMsg = document.createElement('div');
    flashMsg.innerText = 'Download started...';
    flashMsg.style.position = 'fixed';
    flashMsg.style.top = '50%';
    flashMsg.style.left = '50%';
    flashMsg.style.transform = 'translate(-50%, -50%)';
    flashMsg.style.padding = '1rem 2rem';
    flashMsg.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    flashMsg.style.color = '#fff';
    flashMsg.style.fontSize = '1.5rem';
    flashMsg.style.borderRadius = '8px';
    flashMsg.style.zIndex = '9999';
    document.getElementById('webViewContent').appendChild(flashMsg);
    setTimeout(() => {
      flashMsg.remove();
      const modalEl = document.getElementById('webViewModal');
      const modalInstance = bootstrap.Modal.getInstance(modalEl);
      if (modalInstance) {
        modalInstance.hide();
      }
      document.getElementById('receiverProgress').scrollIntoView({ behavior: 'smooth' });
    }, 3000);
    // Trigger file download.
    fetchAssetViaGET(resolvedHref)
      .then(dataUrl => {
        const a = document.createElement('a');
        a.href = dataUrl;
        a.download = resolvedHref;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      })
      .catch(err => console.error("Error fetching asset for download:", err));
  }
});


  });
}


function loadPage(pageName, htmlContent) {
  // Inject the HTML into the modal with assets processed.
  loadIndexWithAssetsSequentially(htmlContent);
  
  // Update the current page name.
  currentPageName = pageName;
  document.getElementById('currentPageUrl').value = currentPageName;
  
  // If we're not at the end of history, truncate forward history.
  if (historyIndex < pageHistory.length - 1) {
    pageHistory = pageHistory.slice(0, historyIndex + 1);
  }
  
  // Record the new page in history and update the history index.
  pageHistory.push(pageName);
  historyIndex = pageHistory.length - 1;
  
  // Update the navigation buttons.
  updateNavButtons();
}


// Add event listener for the Back button.
document.getElementById('navBackBtn').addEventListener('click', () => {
  if (historyIndex > 0) {
    historyIndex--;
    const prevPage = pageHistory[historyIndex];
    fetchAssetViaGET(prevPage)
      .then(dataUrl => fetch(dataUrl))
      .then(response => response.text())
      .then(htmlContent => {
        currentPageName = prevPage;
        document.getElementById('currentPageUrl').value = currentPageName;
        loadIndexWithAssetsSequentially(htmlContent);
        updateNavButtons();
      })
      .catch(err => console.error("Error loading page:", err));
  }
});

// Add event listener for the Forward button.
document.getElementById('navForwardBtn').addEventListener('click', () => {
  if (historyIndex < pageHistory.length - 1) {
    historyIndex++;
    const nextPage = pageHistory[historyIndex];
    fetchAssetViaGET(nextPage)
      .then(dataUrl => fetch(dataUrl))
      .then(response => response.text())
      .then(htmlContent => {
        currentPageName = nextPage;
        document.getElementById('currentPageUrl').value = currentPageName;
        loadIndexWithAssetsSequentially(htmlContent);
        updateNavButtons();
      })
      .catch(err => console.error("Error loading page:", err));
  }
});

function showWebViewErrorOverlay(message) {
  const modalEl = document.getElementById('webViewModal');
  if (!modalEl) return;
  console.log("showWebViewErrorOverlay called, modalEl:", modalEl);
  
  let overlay = modalEl.querySelector('.error-overlay');
  if (!overlay) {
    overlay = document.createElement('div');
    overlay.className = 'error-overlay';
    // Style the overlay as a small, centered box:
    overlay.style.position = 'fixed';
    overlay.style.width = '600px';
    overlay.style.height = '150px';
    overlay.style.top = '50%';
    overlay.style.left = '50%';
    overlay.style.transform = 'translate(-50%, -50%)';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
    overlay.style.color = '#fff';
    overlay.style.display = 'flex';
    overlay.style.alignItems = 'center';
    overlay.style.justifyContent = 'center';
    overlay.style.fontSize = '1.5rem';
    overlay.style.zIndex = '1050';
    modalEl.appendChild(overlay);
    
    // Add a click listener on the modal to hide the overlay when clicked outside the box:
    modalEl.addEventListener('click', function modalClickListener(event) {
      // If the click target is NOT within the overlay, hide the overlay.
      if (!overlay.contains(event.target)) {
        overlay.style.display = 'none';
      }
    });
  }
  
  overlay.innerText = message;
  overlay.style.display = 'flex';
}

// Helper function that loads a page from a given URL via GET.
function loadPageFromUrl(url) {
  // If the URL has a dot but does NOT end with ".html", then fire an alert.
  if (url.indexOf('.') !== -1 && !url.endsWith('.html')) {
    alert("File name must end in .html");
    return;
  }
  
  // If the URL has no dot at all OR it ends with a slash, then assume it's a directory.
  // In that case, convert it to "<name>/index.html"
  if (url.indexOf('.') === -1 || url.endsWith('/')) {
    if (!url.endsWith('/')) {
      url = url + '/index.html';
    } else {
      url = url + 'index.html';
    }
  }
  
  // Normalize the URL to a root-relative path using the URL constructor.
  // This forces the URL to be resolved relative to the site root.
  const normalizedUrl = new URL(url, window.location.origin).pathname;
  
  // Set the current page name to the normalized URL.
  currentPageName = normalizedUrl;
  document.getElementById('currentPageUrl').value = currentPageName;
  
  // Show spinner immediately.
  document.getElementById('webViewContent').innerHTML =
    '<div id="spinnerContainer"><div class="spinner"></div></div>';
  
  // Proceed to fetch and load the page using the normalized URL.
  fetchAssetViaGET(normalizedUrl)
    .then(dataUrl => fetch(dataUrl))
    .then(response => response.text())
    .then(htmlContent => {
      loadPage(normalizedUrl, htmlContent);
    })
    .catch(err => {
      document.getElementById('webViewContent').innerHTML =
        "<p style='padding: 1rem;'>Error: " + err + "</p>";
    });
}



// When the user presses Enter in the currentPageUrl textbox.
document.getElementById('currentPageUrl').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    loadPageFromUrl(this.value);
  }
});

// When the Go! button is clicked.
document.getElementById('goBtn').addEventListener('click', function() {
  const url = document.getElementById('currentPageUrl').value;
  loadPageFromUrl(url);
});


// When the user presses Enter in the currentPageUrl textbox.
document.getElementById('currentPageUrl').addEventListener('keydown', function(e) {
  if (e.key === 'Enter') {
    loadPageFromUrl(this.value);
  }
});

// When the Go! button is clicked.
document.getElementById('goBtn').addEventListener('click', function() {
  const url = document.getElementById('currentPageUrl').value;
  loadPageFromUrl(url);
});

function updateNavButtons() {
  document.getElementById('navBackBtn').disabled = (historyIndex <= 0);
  document.getElementById('navForwardBtn').disabled = (historyIndex >= pageHistory.length - 1);
}

function normalizePath(path) {
  // Remove any leading slash from the path.
  return path.startsWith('/') ? path.slice(1) : path;
}

function removeAllReceivedFiles() {
  if (confirm("Are you sure you want to remove all received files?")) {
    persistentReceivedFiles = [];
    saveReceivedFilesToLocalStorage(persistentReceivedFiles);
    updateReceivedFilesUI();
  }
}

function clearAllSentFiles() {
  if (confirm("Are you sure you want to clear all sent files?")) {
    persistentSentFiles = [];
    saveSentFilesToLocalStorage(persistentSentFiles);
    updateSentFilesUI();
  }
}
function updateModalProgressBar() {
  const modalProgressBar = document.getElementById('modalDownloadProgressBar');
  const modalFilename = document.getElementById('modalDownloadFilename');
  
  console.log("updateModalProgressBar called");
  console.log("currentPageName:", currentPageName);
  
  // Log all active transfer file names
  let currentTransfer = null;
  for (let key in activeTransfers) {
    if (activeTransfers[key].header) {
      console.log(`activeTransfers[${key}].header.fileName: "${activeTransfers[key].header.fileName}"`);
      if (activeTransfers[key].header.fileName.trim() === currentPageName) {
        currentTransfer = activeTransfers[key];
        break;
      }
    }
  }
  
  // If no active transfer exactly matches currentPageName,
  // then fall back to the first active transfer (this will catch assets being fetched).
  if (!currentTransfer) {
    console.log("No active transfer found matching currentPageName. Falling back to first active transfer if any.");
    for (let key in activeTransfers) {
      if (activeTransfers[key].header) {
        currentTransfer = activeTransfers[key];
        break;
      }
    }
  }
  
  if (!currentTransfer) {
    console.log("No active transfers available. Resetting modal progress bar.");
    modalProgressBar.style.width = "0%";
    modalProgressBar.innerText = "0%";
    modalFilename.innerText = "";
    return;
  }
  
  // Update the modal to show the file being fetched.
  modalFilename.innerText = currentTransfer.header.fileName;
  
  // Calculate progress using the number of contiguous packets received.
  const total = currentTransfer.totalChunks || 1;
  let contiguous = 1;
  while (currentTransfer.received[contiguous]) contiguous++;
  contiguous--; // highest contiguous packet
  
  const percent = Math.floor((contiguous / total) * 100);
  modalProgressBar.style.width = percent + "%";
  modalProgressBar.innerText = percent > 0 ? percent + "%" : "0%";
  
  console.log(`Modal progress for "${currentTransfer.header.fileName}": ${percent}% (${contiguous}/${total})`);
}


            </script>
            <footer style="text-align: center; margin-top: 20px;">
                <a href="https://github.com/madpsy/kiss-tnc-file-transfer" target="_blank">Github Repo</a>
            </footer>

</body>

</html>